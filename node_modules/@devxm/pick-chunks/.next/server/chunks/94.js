"use strict";
exports.id = 94;
exports.ids = [94];
exports.modules = {

/***/ 7262:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ store),
/* harmony export */   "i": () => (/* binding */ clearChunksStore)
/* harmony export */ });
let store = {};
const clearChunksStore = ()=>{
    store = {};
};


/***/ }),

/***/ 6424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Y": () => (/* binding */ clearStore),
  "_": () => (/* binding */ getAllChunks)
});

// EXTERNAL MODULE: external "@babel/parser"
var parser_ = __webpack_require__(8491);
// EXTERNAL MODULE: external "@babel/traverse"
var traverse_ = __webpack_require__(7459);
var traverse_default = /*#__PURE__*/__webpack_require__.n(traverse_);
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(7147);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(1017);
;// CONCATENATED MODULE: ./constants/extensions.ts
const extensions = [
    ".js",
    ".ts",
    ".tsx",
    "/index.js",
    "/index.ts",
    "/index.tsx"
];

;// CONCATENATED MODULE: ./utils/getAllChunks.ts





// store object
let store = {
    shallow: {
        skipUnnamedChunks: {},
        keepUnnamedChunks: {}
    },
    deep: {
        skipUnnamedChunks: {},
        keepUnnamedChunks: {}
    }
};
const clearStore = ()=>{
    store = {
        shallow: {
            skipUnnamedChunks: {},
            keepUnnamedChunks: {}
        },
        deep: {
            skipUnnamedChunks: {},
            keepUnnamedChunks: {}
        }
    };
};
const getAllChunks = (path, root, getDescendant = false, skipImportWithoutChunkName)=>{
    //resolving path to absolute path 
    path = (0,external_path_.resolve)(root, path);
    const descendant = getDescendant ? "deep" : "shallow";
    const unnamedChunks = skipImportWithoutChunkName ? "skipUnnamedChunks" : "keepUnnamedChunks";
    // path is considered cyclic as it is visited but not completed execution
    if (store[descendant][unnamedChunks][path] === null) {
        return Promise.resolve({
            path,
            children: [],
            chunks: new Set(),
            isCyclic: true
        });
    }
    //if chunks for given combination of descendant, skipUnnamedChunks and path is already calculated then return it
    if (store[descendant][unnamedChunks][path] !== undefined) {
        return Promise.resolve(store[descendant][unnamedChunks][path]);
    }
    store[descendant][unnamedChunks][path] = null;
    const cwd = (0,external_path_.dirname)(path);
    const code = (0,external_fs_.readFileSync)(path).toString();
    const ast = parser_.parse(code, {
        sourceType: "module",
        plugins: [
            "jsx",
            "typescript",
            "classProperties",
            "exportDefaultFrom"
        ]
    });
    const { staticImports , dynamicImports , chunkPathToName  } = getImports(ast, skipImportWithoutChunkName);
    const chunks = new Map();
    const children = [];
    dynamicImports.forEach((chunk)=>{
        let chunkPath = chunk;
        for (const extension of extensions){
            if (!chunkPath.endsWith(extension)) {
                chunkPath += extension;
            }
            const pathToChunk = (0,external_path_.resolve)(cwd, chunkPath);
            const pathToChunkWithRoot = (0,external_path_.resolve)(root, chunkPath);
            const isRelative = chunkPath[0] === "." && (0,external_fs_.existsSync)(pathToChunk);
            const isFromRoot = chunkPath[0] !== "." && (0,external_fs_.existsSync)(pathToChunkWithRoot);
            if (!isRelative && !isFromRoot) {
                chunkPath = chunk;
                continue;
            }
            if (isRelative) {
                chunks.set(pathToChunk, chunkPathToName[chunk] || (0,external_path_.relative)(root, pathToChunk));
                if (getDescendant) {
                    children.push(getAllChunks(pathToChunk, root, getDescendant, skipImportWithoutChunkName));
                }
            } else if (isFromRoot) {
                chunks.set(pathToChunkWithRoot, chunkPathToName[chunk] || (0,external_path_.relative)(root, pathToChunkWithRoot));
                if (getDescendant) {
                    children.push(getAllChunks(pathToChunkWithRoot, root, getDescendant, skipImportWithoutChunkName));
                }
            }
        }
    });
    dynamicImports.clear();
    // Traverse children of current path
    for (const staticImport of staticImports){
        let staticImportPath = staticImport;
        for (const extension of extensions){
            if (!staticImportPath.endsWith(extension)) {
                staticImportPath += extension;
            }
            const pathToImport = (0,external_path_.resolve)(cwd, staticImportPath);
            const pathToImportWithRoot = (0,external_path_.resolve)(root, staticImportPath);
            const isRelative = staticImportPath[0] === "." && (0,external_fs_.existsSync)(pathToImport);
            const isFromRoot = staticImportPath[0] !== "." && (0,external_fs_.existsSync)(pathToImportWithRoot);
            if (!isRelative && !isFromRoot) {
                staticImportPath = staticImport;
                continue;
            }
            if (isRelative) {
                children.push(getAllChunks(pathToImport, root, getDescendant, skipImportWithoutChunkName));
            } else if (isFromRoot) {
                children.push(getAllChunks(pathToImportWithRoot, root, getDescendant, skipImportWithoutChunkName));
            }
        }
    }
    return new Promise((resolve1)=>{
        Promise.all(children).then((childChunks)=>{
            const allChunks = childChunks.reduce((all, curr)=>{
                return [
                    ...all,
                    ...curr.chunks
                ];
            }, [
                ...chunks
            ]);
            store[descendant][unnamedChunks][path] = {
                path,
                chunks: new Map(allChunks),
                children: childChunks
            };
            resolve1(store[descendant][unnamedChunks][path]);
        });
    });
};
// fetching all the static dynamic imports and chunk names
const getImports = (ast, skipImportWithoutChunkName)=>{
    const staticImports = [];
    const dynamicImports = new Set();
    const chunkPathToName = {};
    traverse_default()(ast, {
        ImportDeclaration (path) {
            staticImports.push(path.node.source.value);
        },
        CallExpression (path) {
            if (path.node.callee.type === "Import") {
                const comments = path.node.arguments[0].leadingComments;
                const filePath = path.node.arguments[0].value;
                if (!filePath) {
                    return;
                }
                if (comments) {
                    for (const comment of comments){
                        const chunkNameComment = comment.value.replace("'", '"');
                        if (chunkNameComment.includes("webpackChunkName")) {
                            // Assuming webpackChunkName comment to be of format /* webpackChunkName: "name" */
                            chunkPathToName[filePath] = chunkNameComment.split('"')[1];
                            dynamicImports.add(filePath);
                            return;
                        }
                    }
                }
                if (!skipImportWithoutChunkName) {
                    chunkPathToName[filePath] = undefined;
                    dynamicImports.add(filePath);
                }
            }
        },
        ExportNamedDeclaration (path) {
            if (!!path.node.source) {
                staticImports.push(path.node.source.value);
            }
        },
        ExportAllDeclaration (path) {
            if (!!path.node.source) {
                staticImports.push(path.node.source.value);
            }
        }
    });
    return {
        staticImports,
        dynamicImports,
        chunkPathToName
    };
};


/***/ })

};
;