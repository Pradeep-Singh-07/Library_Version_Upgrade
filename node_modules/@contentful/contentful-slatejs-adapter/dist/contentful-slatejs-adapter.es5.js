'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Contentful = require('@contentful/rich-text-types');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var Contentful__namespace = /*#__PURE__*/_interopNamespace(Contentful);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Ensures that data defaults to an empty object.
 */
var getDataOrDefault = function (value) { return value || {}; };

var defaultSchema = {};
/**
 * Creates an instance of Schema from json.
 *
 * @export
 * @param {SchemaJSON} [schema=defaultSchema]
 * @returns {Schema}
 */
function fromJSON(schema) {
    if (schema === void 0) { schema = defaultSchema; }
    return {
        /**
         * Check if a `node` is void based on the schema rules.
         *
         * @param {ContentfulElementNode} node
         * @returns
         */
        isVoid: function (node) {
            var _a, _b, _c;
            var root = Object.values(Contentful.BLOCKS).includes(node.nodeType) ? 'blocks' : 'inlines';
            // tslint:disable-next-line
            return (_c = (_b = (_a = schema === null || schema === void 0 ? void 0 : schema[root]) === null || _a === void 0 ? void 0 : _a[node.nodeType]) === null || _b === void 0 ? void 0 : _b['isVoid']) !== null && _c !== void 0 ? _c : false;
        },
        isTextContainer: function (nodeType) {
            return Contentful.TEXT_CONTAINERS.includes(nodeType);
        },
    };
}

function toSlatejsDocument(_a) {
    var document = _a.document, schema = _a.schema;
    // TODO:
    // We allow adding data to the root document node, but Slate >v0.5.0
    // has no concept of a root document node. We should determine whether
    // this will be a compatibility problem for existing users.
    return document.content.flatMap(function (node) { return convertNode$1(node, fromJSON(schema)); });
}
function convertNode$1(node, schema) {
    if (node.nodeType === 'text') {
        return convertTextNode(node);
    }
    else {
        var contentfulNode = node;
        var childNodes = contentfulNode.content.flatMap(function (childNode) {
            return convertNode$1(childNode, schema);
        });
        var slateNode = convertElementNode(contentfulNode, childNodes, schema);
        return slateNode;
    }
}
function convertElementNode(contentfulBlock, slateChildren, schema) {
    var children = slateChildren.length === 0 && schema.isTextContainer(contentfulBlock.nodeType)
        ? [{ text: '', data: {} }]
        : slateChildren;
    return {
        type: contentfulBlock.nodeType,
        children: children,
        isVoid: schema.isVoid(contentfulBlock),
        data: getDataOrDefault(contentfulBlock.data),
    };
}
function convertTextNode(node) {
    return __assign({ text: node.value, data: getDataOrDefault(node.data) }, convertTextMarks(node));
}
function convertTextMarks(node) {
    var marks = {};
    for (var _i = 0, _a = node.marks; _i < _a.length; _i++) {
        var mark = _a[_i];
        marks[mark.type] = true;
    }
    return marks;
}

function toContentfulDocument(_a) {
    var document = _a.document, schema = _a.schema;
    // TODO:
    // We allow adding data to the root document node, but Slate >v0.5.0
    // has no concept of a root document node. We should determine whether
    // this will be a compatibility problem for existing users.
    return {
        nodeType: Contentful__namespace.BLOCKS.DOCUMENT,
        data: {},
        content: document.flatMap(function (node) { return convertNode(node, fromJSON(schema)); }),
    };
}
function convertNode(node, schema) {
    var nodes = [];
    if (isSlateElement(node)) {
        var contentfulElement = {
            nodeType: node.type,
            data: getDataOrDefault(node.data),
            content: [],
        };
        if (!schema.isVoid(contentfulElement)) {
            contentfulElement.content = node.children.flatMap(function (childNode) {
                return convertNode(childNode, schema);
            });
        }
        if (contentfulElement.content.length === 0 && schema.isTextContainer(node.type)) {
            contentfulElement.content.push(convertText({ text: '', data: {} }));
        }
        nodes.push(contentfulElement);
    }
    else {
        var contentfulText = convertText(node);
        nodes.push(contentfulText);
    }
    return nodes;
}
function convertText(node) {
    node.text; node.data; var marks = __rest(node, ["text", "data"]);
    return {
        nodeType: 'text',
        value: node.text,
        marks: getMarkList(marks),
        data: getDataOrDefault(node.data),
    };
}
function getMarkList(marks) {
    var contentfulMarks = [];
    for (var _i = 0, _a = Object.keys(marks); _i < _a.length; _i++) {
        var mark = _a[_i];
        contentfulMarks.push({ type: mark });
    }
    return contentfulMarks;
}
function isSlateElement(node) {
    return 'type' in node;
}

exports.toContentfulDocument = toContentfulDocument;
exports.toSlatejsDocument = toSlatejsDocument;
//# sourceMappingURL=contentful-slatejs-adapter.es5.js.map
