function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
import throttle from 'lodash/throttle.js';
import Debug from 'debug';
import { EventEmitter } from 'events';
import RESTAPI from './rest/RESTAPI.js';
import SocketManager from './socket/SocketManager.js';
import RemoteContext from './remotecontext/RemoteContext.js';
import ActivityDetection from './util/ActivityDetection.js';
import TokenExpiredError from './rest/TokenExpiredError.js';
import devices from './devices/index.js';
import sessions from './sessions/index.js';
import recordings from './recordings/index.js';
import users from './users/index.js';
import version from './version.js';
const debug = Debug('cbio.CobrowseAPI');
var _activity = /*#__PURE__*/new WeakMap();
var _sockets = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _isBrowserContext = /*#__PURE__*/new WeakMap();
var _getSocketAuth = /*#__PURE__*/new WeakMap();
var _handleSocketOpen = /*#__PURE__*/new WeakMap();
var _handleError = /*#__PURE__*/new WeakMap();
export default class CobrowseAPI extends EventEmitter {
  constructor(token, options = {}) {
    var _options$api;
    super();
    _classPrivateFieldInitSpec(this, _isBrowserContext, {
      get: _get_isBrowserContext,
      set: void 0
    });
    _classPrivateFieldInitSpec(this, _activity, {
      writable: true,
      value: new ActivityDetection()
    });
    _classPrivateFieldInitSpec(this, _sockets, {
      writable: true,
      value: new SocketManager({
        getSocketAuth: () => _classPrivateFieldGet(this, _getSocketAuth).call(this)
      })
    });
    _classPrivateFieldInitSpec(this, _api, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "attachContext", async target => {
      if (_classPrivateFieldGet(this, _isBrowserContext)) return new RemoteContext(target, _classPrivateFieldGet(this, _api), _classPrivateFieldGet(this, _sockets));
    });
    _classPrivateFieldInitSpec(this, _getSocketAuth, {
      writable: true,
      value: throttle(async () => {
        // try to fetch an updated token for the socket connection
        // we use a token for the user to initally connect the socket,
        // we then add extra subscriptions to that socket as requried
        const user = await _classPrivateFieldGet(this, _api).fetch('/api/1/users/me');
        return {
          token: user.notification_token,
          url: user.notification_url
        };
      }, 60 * 60 * 1000)
    });
    _classPrivateFieldInitSpec(this, _handleSocketOpen, {
      writable: true,
      value: () => {
        this.emit('socket:open');
      }
    });
    _classPrivateFieldInitSpec(this, _handleError, {
      writable: true,
      value: e => {
        // if the JWT has expired, there's no point in keeping on trying
        // to connect the sockets, so kill the activity watching and socket
        // loop. We'll restart these if the token is updated
        if (e instanceof TokenExpiredError) {
          console.warn('The CobrowseIO token has expired. Please set a new token');
          if (_classPrivateFieldGet(this, _isBrowserContext)) {
            _classPrivateFieldGet(this, _activity).stop();
            _classPrivateFieldGet(this, _sockets).disconnect();
          }
          this.emit('error', e);
        } else throw e;
      }
    });
    debug('constructed CobrowseAPI');
    _classPrivateFieldSet(this, _api, new RESTAPI((_options$api = options.api) !== null && _options$api !== void 0 ? _options$api : 'https://cobrowse.io'));

    // headers for REST api calls
    _classPrivateFieldGet(this, _api).setHeader('X-CobrowsePlatform', 'agent-sdk');
    _classPrivateFieldGet(this, _api).setHeader('X-CobrowseSDKVersion', version);
    _classPrivateFieldGet(this, _api).setHeader('X-CobrowseAPIVersion', '1.2.0');
    if (_classPrivateFieldGet(this, _isBrowserContext)) {
      // and some on sockets
      _classPrivateFieldGet(this, _sockets).setHeader('X-CobrowsePlatform', 'agent-sdk');
      _classPrivateFieldGet(this, _sockets).setHeader('X-CobrowseSDKVersion', version);
      _classPrivateFieldGet(this, _sockets).on('error', _classPrivateFieldGet(this, _handleError));
      _classPrivateFieldGet(this, _sockets).on('open', _classPrivateFieldGet(this, _handleSocketOpen));
    }
    if (token) this.token = token;
    if (_classPrivateFieldGet(this, _isBrowserContext)) {
      // watch for activity in the window, we only connect sockets when
      // windows are actually in use
      _classPrivateFieldGet(this, _activity).start();
      _classPrivateFieldGet(this, _activity).on('active', () => _classPrivateFieldGet(this, _sockets).connect().catch(_classPrivateFieldGet(this, _handleError)));
      _classPrivateFieldGet(this, _activity).on('inactive', _classPrivateFieldGet(this, _sockets).disconnect);
    }
  }
  set token(token) {
    debug('updated token to', token);
    if (token) _classPrivateFieldGet(this, _api).setHeader('Authorization', `Bearer ${token}`);else _classPrivateFieldGet(this, _api).removeHeader('Authorization');

    // try to restart the activity loop if the token is updated
    // see the comment in #handleError for why this is
    if (_classPrivateFieldGet(this, _isBrowserContext)) _classPrivateFieldGet(this, _activity).start();
  }
  get token() {
    const header = _classPrivateFieldGet(this, _api).getHeader('Authorization');
    if (!header) return null;
    return header.replace(/^Bearer /, '');
  }
  set license(license) {
    if (license) _classPrivateFieldGet(this, _api).setHeader('X-CobrowseLicense', license);else _classPrivateFieldGet(this, _api).removeHeader('X-CobrowseLicense');
  }
  get license() {
    return _classPrivateFieldGet(this, _api).getHeader('X-CobrowseLicense');
  }
  get api() {
    return _classPrivateFieldGet(this, _api).baseurl;
  }
  get devices() {
    return devices(_classPrivateFieldGet(this, _api), _classPrivateFieldGet(this, _sockets));
  }
  get sessions() {
    return sessions(_classPrivateFieldGet(this, _api), _classPrivateFieldGet(this, _sockets));
  }
  get recordings() {
    return recordings(_classPrivateFieldGet(this, _api));
  }
  get users() {
    return users(_classPrivateFieldGet(this, _api));
  }
}
function _get_isBrowserContext() {
  return typeof window === 'object' && typeof document === 'object';
}