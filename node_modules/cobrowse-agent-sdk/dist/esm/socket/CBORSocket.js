function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
import Debug from 'debug';
import { decode as cborDecode, encode as cborEncode } from 'cbor-x';
import { EventEmitter } from 'events';
const debug = Debug('cbio.CBORSocket');
var _delegate = /*#__PURE__*/new WeakMap();
var _closed = /*#__PURE__*/new WeakMap();
var _socket = /*#__PURE__*/new WeakMap();
var _attempts = /*#__PURE__*/new WeakMap();
var _maxDelay = /*#__PURE__*/new WeakMap();
var _minDelay = /*#__PURE__*/new WeakMap();
var _pingInterval = /*#__PURE__*/new WeakMap();
var _openSuccessTimeout = /*#__PURE__*/new WeakMap();
var _reconnectTimeout = /*#__PURE__*/new WeakMap();
var _messageId = /*#__PURE__*/new WeakMap();
var _lastMessageAck = /*#__PURE__*/new WeakMap();
var _createSocket = /*#__PURE__*/new WeakMap();
var _handleOpen = /*#__PURE__*/new WeakMap();
var _handleAck = /*#__PURE__*/new WeakMap();
var _handleMessage = /*#__PURE__*/new WeakMap();
var _reconnectDelay = /*#__PURE__*/new WeakMap();
var _reconnect = /*#__PURE__*/new WeakMap();
var _handleClose = /*#__PURE__*/new WeakMap();
var _handleError = /*#__PURE__*/new WeakMap();
var _sendPing = /*#__PURE__*/new WeakMap();
export default class CBORSocket extends EventEmitter {
  // message IDs for flow control

  constructor(delegate) {
    super();
    _classPrivateFieldInitSpec(this, _delegate, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _closed, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec(this, _socket, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _attempts, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec(this, _maxDelay, {
      writable: true,
      value: 60 * 1000
    });
    _classPrivateFieldInitSpec(this, _minDelay, {
      writable: true,
      value: 1000 + Math.floor(1000 * Math.random())
    });
    _classPrivateFieldInitSpec(this, _pingInterval, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _openSuccessTimeout, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _reconnectTimeout, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _messageId, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec(this, _lastMessageAck, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec(this, _createSocket, {
      writable: true,
      value: async () => {
        if (_classPrivateFieldGet(this, _socket)) {
          console.error('Socket already exists');
          return;
        }
        debug('creating ws');
        // Generate the URL. Important: this might be an
        // asynchronous operation (e.g. getting the server
        // to generate a token). So we need to be careful
        // to re-check the intended state of the socket
        // after a successful url generation
        const url = await _classPrivateFieldGet(this, _delegate).getUrl();

        // the we've been cleaned up while we were fetching
        // the URL, we can stop here
        if (_classPrivateFieldGet(this, _closed)) return;

        // if another call to createSocket happen to create
        // socket before we did then we can also bail here
        if (_classPrivateFieldGet(this, _socket)) return;

        // otherwise we have the URL so create the underlying
        // WebSocket instance
        const socket = new WebSocket(url);
        socket.binaryType = 'arraybuffer';
        socket.addEventListener('open', _classPrivateFieldGet(this, _handleOpen));
        socket.addEventListener('message', _classPrivateFieldGet(this, _handleMessage));
        socket.addEventListener('close', _classPrivateFieldGet(this, _handleClose));
        socket.addEventListener('error', _classPrivateFieldGet(this, _handleError));

        // save the socket on the instance
        _classPrivateFieldSet(this, _socket, socket);
      }
    });
    _classPrivateFieldInitSpec(this, _handleOpen, {
      writable: true,
      value: () => {
        debug('ws opened');
        this.emit('open');
        clearTimeout(_classPrivateFieldGet(this, _openSuccessTimeout));
        // require socket to be held opne for a little time before
        // resetting the backoff algorithm
        _classPrivateFieldSet(this, _openSuccessTimeout, setTimeout(() => {
          debug('counting open as success');
          _classPrivateFieldSet(this, _attempts, 0);
        }, 5 * 1000));
      }
    });
    _classPrivateFieldInitSpec(this, _handleAck, {
      writable: true,
      value: ack => {
        _classPrivateFieldSet(this, _lastMessageAck, ack);
      }
    });
    _classPrivateFieldInitSpec(this, _handleMessage, {
      writable: true,
      value: message => {
        try {
          const {
            event,
            data,
            ack
          } = cborDecode(new Uint8Array(message.data));
          if (ack) return _classPrivateFieldGet(this, _handleAck).call(this, ack);
          if (!event) return console.error('Socket received message without event', message);
          return this.emit('event', event, data);
        } catch (e) {
          return console.error('Error processing message', message.data, e.stack);
        }
      }
    });
    _classPrivateFieldInitSpec(this, _reconnectDelay, {
      writable: true,
      value: attempt => {
        const randomFactor = 1 + 0.5 * Math.random();
        const delay = Math.floor((300 * attempt) ** 1.2 * randomFactor);
        return Math.min(Math.max(_classPrivateFieldGet(this, _minDelay), delay), _classPrivateFieldGet(this, _maxDelay));
      }
    });
    _classPrivateFieldInitSpec(this, _reconnect, {
      writable: true,
      value: () => {
        // if the socket was destroyed then don't try to reconnect
        if (_classPrivateFieldGet(this, _closed)) {
          debug('reconnect skipped as socket was closed');
          return;
        }

        // never try to schedule multiple reconnects
        if (_classPrivateFieldGet(this, _reconnectTimeout)) {
          debug('reconnect skipped as reconnect already scheduled');
          return;
        }

        // if we're offline then don't try to reconnect yet, just wait a bit
        // and try again
        if (navigator.onLine === false) {
          debug('navigator offline');
          _classPrivateFieldSet(this, _reconnectTimeout, setTimeout(() => {
            _classPrivateFieldSet(this, _reconnectTimeout, null);
            _classPrivateFieldGet(this, _reconnect).call(this);
          }, 1000));
          return;
        }

        // otherwise work out the backoff delay and schedule reconnection
        const delay = _classPrivateFieldGet(this, _reconnectDelay).call(this, _classPrivateFieldGet(this, _attempts));
        debug('reconnecting in', delay, 'attempts', _classPrivateFieldGet(this, _attempts));
        _classPrivateFieldSet(this, _reconnectTimeout, setTimeout(async () => {
          _classPrivateFieldSet(this, _reconnectTimeout, null);
          if (_classPrivateFieldGet(this, _closed)) console.warn('tried to reconnect after close');else {
            _classPrivateFieldSet(this, _socket, null);
            await _classPrivateFieldGet(this, _createSocket).call(this).catch(_classPrivateFieldGet(this, _handleError));
          }
        }, delay));
        _classPrivateFieldSet(this, _attempts, _classPrivateFieldGet(this, _attempts) + 1);
      }
    });
    _classPrivateFieldInitSpec(this, _handleClose, {
      writable: true,
      value: () => {
        debug('ws closed');
        this.emit('close');
        debug('resetting message acks');
        _classPrivateFieldSet(this, _messageId, 0);
        _classPrivateFieldSet(this, _lastMessageAck, 0);

        // backoff reconnection
        if (!_classPrivateFieldGet(this, _closed)) _classPrivateFieldGet(this, _reconnect).call(this);

        // cancel pending success timeout
        clearTimeout(_classPrivateFieldGet(this, _openSuccessTimeout));
      }
    });
    _classPrivateFieldInitSpec(this, _handleError, {
      writable: true,
      value: error => {
        this.emit('error', error);
      }
    });
    _classPrivateFieldInitSpec(this, _sendPing, {
      writable: true,
      value: () => {
        this.send('ping');
      }
    });
    _defineProperty(this, "messageLag", () => {
      // if no ack received at all, then don't count as lagging
      // could mean server doesn't support acks or something
      if (!_classPrivateFieldGet(this, _lastMessageAck)) return 0;
      return _classPrivateFieldGet(this, _messageId) - _classPrivateFieldGet(this, _lastMessageAck);
    });
    _defineProperty(this, "setMaxReconnectDelay", delay => {
      debug('set max delay', delay);
      _classPrivateFieldSet(this, _maxDelay, delay);
    });
    _defineProperty(this, "setMinReconnectDelay", delay => {
      debug('set min delay', delay);
      _classPrivateFieldSet(this, _minDelay, delay);
    });
    _defineProperty(this, "send", (event, data) => {
      if (!this.connected) return false;
      _classPrivateFieldSet(this, _messageId, _classPrivateFieldGet(this, _messageId) + 1);
      _classPrivateFieldGet(this, _socket).send(cborEncode(data ? {
        event,
        id: _classPrivateFieldGet(this, _messageId),
        data
      } : {
        event
      }));
      return true;
    });
    _defineProperty(this, "close", (...args) => {
      debug('close');
      _classPrivateFieldSet(this, _closed, true);
      if (_classPrivateFieldGet(this, _socket)) {
        try {
          _classPrivateFieldGet(this, _socket).close(...args);
        } catch (e) {
          debug('error closing socket', e);
        }
      }
      _classPrivateFieldSet(this, _socket, null);
      this.removeAllListeners();
      clearTimeout(_classPrivateFieldGet(this, _reconnectTimeout));
      clearInterval(_classPrivateFieldGet(this, _pingInterval));
      if (typeof window !== 'undefined') window.removeEventListener('unload', this.close);
    });
    debug('created cbor socket');
    _classPrivateFieldSet(this, _delegate, delegate);
    _classPrivateFieldSet(this, _pingInterval, setInterval(_classPrivateFieldGet(this, _sendPing), 60 * 1000));
    if (typeof window !== 'undefined') window.addEventListener('unload', this.close);
    this.on('error', e => debug('ws errored', e));
    _classPrivateFieldGet(this, _createSocket).call(this).catch(_classPrivateFieldGet(this, _handleError));
  }
  get bufferedAmount() {
    if (!_classPrivateFieldGet(this, _socket)) return Infinity;
    return _classPrivateFieldGet(this, _socket).bufferedAmount;
  }
  get connected() {
    if (_classPrivateFieldGet(this, _socket)) return _classPrivateFieldGet(this, _socket).readyState === _classPrivateFieldGet(this, _socket).OPEN;else return false;
  }
}