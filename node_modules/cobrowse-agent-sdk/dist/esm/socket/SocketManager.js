function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
import { EventEmitter } from 'events';
import CBORSocket from './CBORSocket.js';
var _subscriptions = /*#__PURE__*/new WeakMap();
var _headers = /*#__PURE__*/new WeakMap();
var _socket = /*#__PURE__*/new WeakMap();
var _delegate = /*#__PURE__*/new WeakMap();
var _generateUrl = /*#__PURE__*/new WeakMap();
var _onOpen = /*#__PURE__*/new WeakMap();
var _onEvent = /*#__PURE__*/new WeakMap();
var _onError = /*#__PURE__*/new WeakMap();
export default class SocketManager extends EventEmitter {
  constructor(delegate) {
    super();
    _classPrivateFieldInitSpec(this, _subscriptions, {
      writable: true,
      value: new Set()
    });
    _classPrivateFieldInitSpec(this, _headers, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec(this, _socket, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _delegate, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "setHeader", (key, value) => {
      _classPrivateFieldGet(this, _headers)[key] = value;
    });
    _defineProperty(this, "connect", async () => {
      // create the socket if not already created, the function passed in to
      // the socket consturctor will always use the latest auth token saved on
      // the instance on reconnects
      if (!_classPrivateFieldGet(this, _socket)) {
        _classPrivateFieldSet(this, _socket, new CBORSocket({
          getUrl: async () => _classPrivateFieldGet(this, _generateUrl).call(this, await _classPrivateFieldGet(this, _delegate).getSocketAuth())
        }));
        _classPrivateFieldGet(this, _socket).setMaxReconnectDelay(10 * 60 * 1000);
        _classPrivateFieldGet(this, _socket).on('open', _classPrivateFieldGet(this, _onOpen));
        _classPrivateFieldGet(this, _socket).on('event', _classPrivateFieldGet(this, _onEvent));
        _classPrivateFieldGet(this, _socket).on('error', _classPrivateFieldGet(this, _onError));
      }
    });
    _classPrivateFieldInitSpec(this, _generateUrl, {
      writable: true,
      value: ({
        url,
        token
      }) => {
        const headers = Object.keys(_classPrivateFieldGet(this, _headers)).map(key => `${key}=${_classPrivateFieldGet(this, _headers)[key]}`).join('&');
        const wsUrl = url.replace('https://', 'wss://').replace('http://', 'ws://');
        return `${wsUrl}/sockets/1/ws?access_token=${token}&${headers}`;
      }
    });
    _classPrivateFieldInitSpec(this, _onOpen, {
      writable: true,
      value: () => {
        // resubscribe tokens on successful (re)connections.
        [..._classPrivateFieldGet(this, _subscriptions)].forEach(tokenFn => {
          const token = tokenFn();
          if (token) this.send('subscribe', token);
        });
        this.emit('open');
      }
    });
    _classPrivateFieldInitSpec(this, _onEvent, {
      writable: true,
      value: (event, data) => {
        this.emit('event', event, data);
      }
    });
    _classPrivateFieldInitSpec(this, _onError, {
      writable: true,
      value: e => {
        this.emit('error', e);
      }
    });
    _defineProperty(this, "send", (event, data) => {
      if (!_classPrivateFieldGet(this, _socket)) return false;
      return _classPrivateFieldGet(this, _socket).send(event, data);
    });
    _defineProperty(this, "disconnect", () => {
      if (_classPrivateFieldGet(this, _socket)) {
        _classPrivateFieldGet(this, _socket).close();
        _classPrivateFieldSet(this, _socket, null);
      }
    });
    _defineProperty(this, "subscribe", subscriptionTokenFn => {
      _classPrivateFieldGet(this, _subscriptions).add(subscriptionTokenFn);

      // ensure a connection has been attempted
      this.connect().catch(_classPrivateFieldGet(this, _onError));
      if (_classPrivateFieldGet(this, _socket) && subscriptionTokenFn()) {
        this.send('subscribe', subscriptionTokenFn());
      }
    });
    _defineProperty(this, "unsubscribe", tokenFn => {
      _classPrivateFieldGet(this, _subscriptions).delete(tokenFn);
      if (_classPrivateFieldGet(this, _subscriptions).size === 0) this.disconnect();
    });
    _classPrivateFieldSet(this, _delegate, delegate);
    this.setMaxListeners(10000);
  }
}