function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
import { EventEmitter } from 'events';
import throttle from 'lodash/throttle.js';
import Debug from 'debug';
const debug = Debug('cbio.ActivityDetection');
var _started = /*#__PURE__*/new WeakMap();
var _active = /*#__PURE__*/new WeakMap();
var _activeTimeout = /*#__PURE__*/new WeakMap();
var _inactiveTime = /*#__PURE__*/new WeakMap();
var _onActivity = /*#__PURE__*/new WeakMap();
var _makeActive = /*#__PURE__*/new WeakMap();
var _makeInactive = /*#__PURE__*/new WeakMap();
export default class ActivityDetection extends EventEmitter {
  constructor(timeout) {
    super();
    _classPrivateFieldInitSpec(this, _started, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec(this, _active, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec(this, _activeTimeout, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec(this, _inactiveTime, {
      writable: true,
      value: 15 * 60 * 1000
    });
    _defineProperty(this, "start", () => {
      if (_classPrivateFieldGet(this, _started)) return;
      _classPrivateFieldSet(this, _started, true);
      debug('started');
      document.addEventListener('mouseenter', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.addEventListener('mouseleave', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.addEventListener('mousemove', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchstart', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchend', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.addEventListener('touchmove', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.addEventListener('visibilitychange', _classPrivateFieldGet(this, _onActivity), {
        capture: true
      });

      // page load counts as possible activity
      _classPrivateFieldGet(this, _onActivity).call(this);
    });
    _defineProperty(this, "stop", () => {
      _classPrivateFieldSet(this, _active, false);
      _classPrivateFieldSet(this, _started, false);
      debug('stopped');
      clearTimeout(_classPrivateFieldGet(this, _activeTimeout));
      this.removeAllListeners();
      document.removeEventListener('mouseenter', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.removeEventListener('mouseleave', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.removeEventListener('mousemove', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchstart', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchend', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.removeEventListener('touchmove', _classPrivateFieldGet(this, _onActivity), {
        capture: true,
        passive: true
      });
      document.removeEventListener('visibilitychange', _classPrivateFieldGet(this, _onActivity), {
        capture: true
      });
    });
    _defineProperty(this, "isActive", () => {
      return _classPrivateFieldGet(this, _active);
    });
    _classPrivateFieldInitSpec(this, _onActivity, {
      writable: true,
      value: throttle(() => {
        _classPrivateFieldGet(this, _makeActive).call(this);
        clearTimeout(_classPrivateFieldGet(this, _activeTimeout));
        _classPrivateFieldSet(this, _activeTimeout, setTimeout(_classPrivateFieldGet(this, _makeInactive), _classPrivateFieldGet(this, _inactiveTime)));
        this.emit('activity');
      }, 500, {
        trailing: false
      })
    });
    _classPrivateFieldInitSpec(this, _makeActive, {
      writable: true,
      value: () => {
        // skip if already active
        if (_classPrivateFieldGet(this, _active)) return;
        // or if the browser thinks it's not visible
        if (document.hidden) {
          debug('window is hidden, not becoming active');
          return;
        }
        // then mark as active and emit event
        _classPrivateFieldSet(this, _active, true);
        debug('became active');
        this.emit('active');
      }
    });
    _classPrivateFieldInitSpec(this, _makeInactive, {
      writable: true,
      value: () => {
        if (_classPrivateFieldGet(this, _active)) {
          _classPrivateFieldSet(this, _active, false);
          debug('became inactive');
          this.emit('inactive');
        }
      }
    });
    if (timeout) _classPrivateFieldSet(this, _inactiveTime, timeout);
  }
}