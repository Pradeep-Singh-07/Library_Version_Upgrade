function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
import qs from 'qs';
import fetch from 'cross-fetch';
import TokenExpiredError from './TokenExpiredError.js';
import APIError from './APIError.js';
var _baseurl = /*#__PURE__*/new WeakMap();
var _headers = /*#__PURE__*/new WeakMap();
var _url = /*#__PURE__*/new WeakMap();
var _handleErrors = /*#__PURE__*/new WeakMap();
export default class RESTAPI {
  constructor(baseurl) {
    _classPrivateFieldInitSpec(this, _baseurl, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _headers, {
      writable: true,
      value: {
        'Content-Type': 'application/json'
      }
    });
    _defineProperty(this, "setHeader", (key, value) => {
      _classPrivateFieldGet(this, _headers)[key] = value;
    });
    _defineProperty(this, "getHeader", key => {
      return _classPrivateFieldGet(this, _headers)[key];
    });
    _defineProperty(this, "removeHeader", key => {
      delete _classPrivateFieldGet(this, _headers)[key];
    });
    _classPrivateFieldInitSpec(this, _url, {
      writable: true,
      value: (url, query) => {
        // ensure relative URLs are resolved from baseurl
        const absolute = new URL(url, _classPrivateFieldGet(this, _baseurl));
        // always set query params
        absolute.search = qs.stringify(query, {
          arrayFormat: 'brackets'
        });
        // strip trailing slashes
        if (/\/$/.test(absolute.pathname)) absolute.pathname = absolute.pathname.slice(0, -1);
        return absolute.toString();
      }
    });
    _defineProperty(this, "create", async (url, state, query = {}, options = {}) => {
      const res = await fetch(_classPrivateFieldGet(this, _url).call(this, url, query), {
        method: 'POST',
        headers: _classPrivateFieldGet(this, _headers),
        body: JSON.stringify(state),
        ...options
      });
      await _classPrivateFieldGet(this, _handleErrors).call(this, res);
      return res.json();
    });
    _defineProperty(this, "list", async (url, query = {}, options = {}) => {
      const res = await fetch(_classPrivateFieldGet(this, _url).call(this, url, query), {
        method: 'GET',
        headers: _classPrivateFieldGet(this, _headers),
        ...options
      });
      await _classPrivateFieldGet(this, _handleErrors).call(this, res);
      const json = await res.json();
      if (!Array.isArray(json)) throw new Error('expected array');
      return json;
    });
    _defineProperty(this, "fetch", async (url, state, query = {}, options = {}) => {
      const res = await fetch(_classPrivateFieldGet(this, _url).call(this, url, query), {
        method: 'GET',
        headers: _classPrivateFieldGet(this, _headers),
        ...options
      });
      await _classPrivateFieldGet(this, _handleErrors).call(this, res);
      return res.json();
    });
    _defineProperty(this, "update", async (url, state, query = {}, options = {}) => {
      const res = await fetch(_classPrivateFieldGet(this, _url).call(this, url, query), {
        method: 'PUT',
        headers: _classPrivateFieldGet(this, _headers),
        body: JSON.stringify(state),
        ...options
      });
      await _classPrivateFieldGet(this, _handleErrors).call(this, res);
      return res.json();
    });
    _defineProperty(this, "destroy", async (url, state, query = {}, options = {}) => {
      const res = await fetch(_classPrivateFieldGet(this, _url).call(this, url, query), {
        method: 'DELETE',
        headers: _classPrivateFieldGet(this, _headers),
        ...options
      });
      await _classPrivateFieldGet(this, _handleErrors).call(this, res);
      return {};
    });
    _classPrivateFieldInitSpec(this, _handleErrors, {
      writable: true,
      value: async res => {
        if (res.status >= 400) {
          const err = await res.json();
          if (err.message === 'jwt expired') throw new TokenExpiredError(err.id, res.status, err.message);else throw new APIError(err.id, res.status, err.message);
        }
      }
    });
    _classPrivateFieldSet(this, _baseurl, baseurl);
  }
  get baseurl() {
    return _classPrivateFieldGet(this, _baseurl);
  }
}