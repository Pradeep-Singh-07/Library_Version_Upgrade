function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
import Debug from 'debug';
import { EventEmitter } from 'events';
import { Session } from '../sessions/index.js';
import protectedSymbol from '../util/protected.js';
import APIError from '../rest/APIError.js';
const debug = Debug('cbio.RemoteContext');
var _target = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
var _onSessionUpdated = /*#__PURE__*/new WeakMap();
var _onPostMessage = /*#__PURE__*/new WeakMap();
export default class RemoteContext extends EventEmitter {
  constructor(target, api, sockets) {
    super();
    _classPrivateFieldInitSpec(this, _target, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onSessionUpdated, {
      writable: true,
      value: data => {
        const existingId = _classPrivateFieldGet(this, _session).id;
        _classPrivateFieldGet(this, _session)[protectedSymbol].updateResource(data);

        // if the ID of the session changes then a new session has been
        // loaded into the iframe, so we should trigger a 'loaded' event
        if (existingId !== _classPrivateFieldGet(this, _session).id) {
          // TODO: should we be replacing the instance of the
          // Session here too? Removing all listeners etc...
          this.emit('session.loaded', _classPrivateFieldGet(this, _session));
        }

        // then trigger the regular update event too
        this.emit('session.updated', _classPrivateFieldGet(this, _session));
      }
    });
    _classPrivateFieldInitSpec(this, _onPostMessage, {
      writable: true,
      value: e => {
        if (e.source !== _classPrivateFieldGet(this, _target)) return;
        debug('got post message', e.data);
        const {
          event,
          data
        } = e.data;
        if (event === 'session' && data) {
          _classPrivateFieldGet(this, _onSessionUpdated).call(this, data);
        }
        if (event === 'screen' && data) {
          this.emit('screen.updated', data);
        }
        if (event === 'error' && data) {
          this.emit('error', new APIError(data.id, null, data.message));
        }
      }
    });
    _defineProperty(this, "setTool", async tool => {
      debug('set tool', tool);
      _classPrivateFieldGet(this, _target).postMessage({
        tool
      }, '*');
      return true;
    });
    _defineProperty(this, "clearAnnotations", async () => {
      debug('clear annotations');
      _classPrivateFieldGet(this, _target).postMessage({
        drawing: null
      }, '*');
      return true;
    });
    _defineProperty(this, "endSession", async () => {
      debug('end session');
      _classPrivateFieldGet(this, _target).postMessage({
        session: {
          state: 'ended'
        }
      }, '*');
      return true;
    });
    _defineProperty(this, "setFullDevice", async state => {
      _classPrivateFieldGet(this, _target).postMessage({
        session: {
          full_device: state
        }
      }, '*');
      return true;
    });
    _defineProperty(this, "setRemoteControl", async state => {
      _classPrivateFieldGet(this, _target).postMessage({
        session: {
          remote_control: state
        }
      }, '*');
      return true;
    });
    _defineProperty(this, "androidBack", async () => {
      _classPrivateFieldGet(this, _target).postMessage({
        control: {
          state: 'keydown',
          key: 'GoBack'
        }
      }, '*');
      return true;
    });
    _defineProperty(this, "androidHome", async () => {
      _classPrivateFieldGet(this, _target).postMessage({
        control: {
          state: 'keydown',
          key: 'GoHome'
        }
      }, '*');
      return true;
    });
    _defineProperty(this, "destroy", () => {
      window.removeEventListener('message', _classPrivateFieldGet(this, _onPostMessage));
      this.removeAllListeners();
      _classPrivateFieldSet(this, _target, null);
    });
    if (!target) throw new Error('context cannot be null');
    if (target instanceof window.HTMLIFrameElement) target = target.contentWindow;
    if (!target.postMessage) throw new Error('target must have postMessage interface');
    _classPrivateFieldSet(this, _target, target);
    _classPrivateFieldSet(this, _session, new Session(api, sockets));
    window.addEventListener('message', _classPrivateFieldGet(this, _onPostMessage));
  }
}