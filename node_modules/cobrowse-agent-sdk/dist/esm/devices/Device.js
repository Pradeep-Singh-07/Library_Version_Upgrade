function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
import Debug from 'debug';
import RESTResource from '../rest/RESTResource.js';
import protectedSymbol from '../util/protected.js';
const debug = Debug('cbio.Device');
var _sockets = /*#__PURE__*/new WeakMap();
var _presence = /*#__PURE__*/new WeakMap();
var _field = /*#__PURE__*/new WeakMap();
var _handleEvent = /*#__PURE__*/new WeakMap();
var _getSocketToken = /*#__PURE__*/new WeakMap();
var _syncPresence = /*#__PURE__*/new WeakMap();
export default class Device extends RESTResource {
  constructor(api, sockets, _resource = {}) {
    super(api, _resource);
    _classPrivateFieldInitSpec(this, _sockets, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _presence, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _field, {
      writable: true,
      value: key => {
        return this[protectedSymbol].field(key);
      }
    });
    _classPrivateFieldInitSpec(this, _handleEvent, {
      writable: true,
      value: (event, resource) => {
        if (event === 'device' && resource.id === this.id) {
          this[protectedSymbol].updateResource(resource);
        }
        if (event === 'presence' && resource.id === this.id) {
          _classPrivateFieldSet(this, _presence, resource);
          this.emit('updated', this);
        }
      }
    });
    _classPrivateFieldInitSpec(this, _getSocketToken, {
      writable: true,
      value: () => {
        return _classPrivateFieldGet(this, _field).call(this, 'notification_token');
      }
    });
    _classPrivateFieldInitSpec(this, _syncPresence, {
      writable: true,
      value: () => {
        _classPrivateFieldGet(this, _sockets).send('sync-presence', this.id);
      }
    });
    _defineProperty(this, "subscribe", async () => {
      _classPrivateFieldGet(this, _sockets).subscribe(_classPrivateFieldGet(this, _getSocketToken));
      _classPrivateFieldGet(this, _sockets).off('event', _classPrivateFieldGet(this, _handleEvent));
      _classPrivateFieldGet(this, _sockets).on('event', _classPrivateFieldGet(this, _handleEvent));

      // sync presence state, and every time the socket opens
      _classPrivateFieldGet(this, _sockets).off('open', _classPrivateFieldGet(this, _syncPresence));
      _classPrivateFieldGet(this, _sockets).on('open', _classPrivateFieldGet(this, _syncPresence));
      _classPrivateFieldGet(this, _syncPresence).call(this);
    });
    _defineProperty(this, "unsubscribe", () => {
      _classPrivateFieldGet(this, _sockets).unsubscribe(_classPrivateFieldGet(this, _getSocketToken));
      _classPrivateFieldGet(this, _sockets).off('event', _classPrivateFieldGet(this, _handleEvent));
    });
    _defineProperty(this, "toJSON", () => {
      return {
        id: this.id,
        device: this.device,
        custom_data: this.custom_data,
        connectable: this.connectable,
        online: this.online,
        last_active: this.last_active
      };
    });
    _classPrivateFieldSet(this, _sockets, sockets);
    debug('constructed Device');
  }
  static url(state = {}) {
    return `/api/1/devices/${state.id || ''}`;
  }
  // eslint-disable-next-line
  get last_active() {
    const lastSeen = new Date(_classPrivateFieldGet(this, _presence) && _classPrivateFieldGet(this, _presence).last_seen || 0).getTime();
    const lastActive = new Date(_classPrivateFieldGet(this, _field).call(this, 'last_active')).getTime();
    return new Date(Math.max(lastSeen, lastActive));
  }
  get online() {
    return !!(_classPrivateFieldGet(this, _presence) && _classPrivateFieldGet(this, _presence).present);
  }
  get connectable() {
    // some devices are never connectable (e.g. if account settings disallow)
    if (!_classPrivateFieldGet(this, _field).call(this, 'connectable')) return false;
    // for devices should have a socket connection, check the presence state
    if (_classPrivateFieldGet(this, _getSocketToken).call(this)) return this.online;
    // otherwise we'll assume they're connectable via native push
    return true;
  }

  // eslint-disable-next-line
  get custom_data() {
    return _classPrivateFieldGet(this, _field).call(this, 'custom_data');
  }
  get device() {
    return _classPrivateFieldGet(this, _field).call(this, 'device');
  }
}