function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
import Debug from 'debug';
import fetch from 'cross-fetch';
import RESTResource from '../rest/RESTResource.js';
import protectedSymbol from '../util/protected.js';
const debug = Debug('cbio.SessionRecording');
var _api = /*#__PURE__*/new WeakMap();
var _field = /*#__PURE__*/new WeakMap();
export default class SessionRecording extends RESTResource {
  constructor(api, resource = {}) {
    super(api, resource);
    _classPrivateFieldInitSpec(this, _api, {
      get: _get_api,
      set: void 0
    });
    _classPrivateFieldInitSpec(this, _field, {
      writable: true,
      value: key => {
        return this[protectedSymbol].field(key);
      }
    });
    _defineProperty(this, "toJSON", () => {
      return {
        id: this.id
      };
    });
    debug('constructed SessionRecording');
  }
  static url(state = {}) {
    if (!state.id) throw new Error('id is required');
    return `/api/1/sessions/${state.id}/recording`;
  }
  get video() {
    const url = `${_classPrivateFieldGet(this, _api).baseurl}${_classPrivateFieldGet(this, _field).call(this, 'video')}`;
    return {
      url: async () => url,
      fetch: async () => fetch(url)
    };
  }
  async events() {
    const actions = await fetch(`${_classPrivateFieldGet(this, _api).baseurl}${_classPrivateFieldGet(this, _field).call(this, 'actions')}`);
    if (!actions.ok) throw new Error(`Failed to fetch events: ${await actions.text()}`);
    return [...(await actions.json()), ..._classPrivateFieldGet(this, _field).call(this, 'events')].sort((a, b) => {
      return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
    });
  }
}
function _get_api() {
  return this[protectedSymbol].getAPI();
}