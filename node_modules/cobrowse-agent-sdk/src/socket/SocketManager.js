import { EventEmitter } from 'events'
import CBORSocket from './CBORSocket.js'

export default class SocketManager extends EventEmitter {
  #subscriptions = new Set()

  #headers = {}

  #socket

  #delegate

  constructor (delegate) {
    super()
    this.#delegate = delegate
    this.setMaxListeners(10000)
  }

  setHeader = (key, value) => {
    this.#headers[key] = value
  }

  connect = async () => {
    // create the socket if not already created, the function passed in to
    // the socket consturctor will always use the latest auth token saved on
    // the instance on reconnects
    if (!this.#socket) {
      this.#socket = new CBORSocket({
        getUrl: async () => this.#generateUrl(await this.#delegate.getSocketAuth())
      })
      this.#socket.setMaxReconnectDelay(10 * 60 * 1000)
      this.#socket.on('open', this.#onOpen)
      this.#socket.on('event', this.#onEvent)
      this.#socket.on('error', this.#onError)
    }
  }

  #generateUrl = ({ url, token }) => {
    const headers = Object.keys(this.#headers).map(key => `${key}=${this.#headers[key]}`).join('&')
    const wsUrl = url.replace('https://', 'wss://').replace('http://', 'ws://')
    return `${wsUrl}/sockets/1/ws?access_token=${token}&${headers}`
  }

  #onOpen = () => {
    // resubscribe tokens on successful (re)connections.
    [...this.#subscriptions].forEach(tokenFn => {
      const token = tokenFn()
      if (token) this.send('subscribe', token)
    })
    this.emit('open')
  }

  #onEvent = (event, data) => {
    this.emit('event', event, data)
  }

  #onError = (e) => {
    this.emit('error', e)
  }

  send = (event, data) => {
    if (!this.#socket) return false
    return this.#socket.send(event, data)
  }

  disconnect = () => {
    if (this.#socket) {
      this.#socket.close()
      this.#socket = null
    }
  }

  subscribe = (subscriptionTokenFn) => {
    this.#subscriptions.add(subscriptionTokenFn)

    // ensure a connection has been attempted
    this.connect().catch(this.#onError)

    if (this.#socket && subscriptionTokenFn()) {
      this.send('subscribe', subscriptionTokenFn())
    }
  }

  unsubscribe = (tokenFn) => {
    this.#subscriptions.delete(tokenFn)
    if (this.#subscriptions.size === 0) this.disconnect()
  }
}
