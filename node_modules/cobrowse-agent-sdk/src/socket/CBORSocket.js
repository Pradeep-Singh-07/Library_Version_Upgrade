import Debug from 'debug'
import { decode as cborDecode, encode as cborEncode } from 'cbor-x'
import { EventEmitter } from 'events'

const debug = Debug('cbio.CBORSocket')

export default class CBORSocket extends EventEmitter {
  #delegate

  #closed = false

  #socket

  #attempts = 0

  #maxDelay = 60 * 1000

  #minDelay = 1000 + Math.floor(1000 * Math.random())

  #pingInterval

  #openSuccessTimeout

  #reconnectTimeout

  // message IDs for flow control
  #messageId = 0

  #lastMessageAck = 0

  constructor (delegate) {
    super()
    debug('created cbor socket')
    this.#delegate = delegate

    this.#pingInterval = setInterval(this.#sendPing, 60 * 1000)

    if (typeof window !== 'undefined') window.addEventListener('unload', this.close)
    this.on('error', e => debug('ws errored', e))

    this.#createSocket().catch(this.#handleError)
  }

  #createSocket = async () => {
    if (this.#socket) {
      console.error('Socket already exists')
      return
    }

    debug('creating ws')
    // Generate the URL. Important: this might be an
    // asynchronous operation (e.g. getting the server
    // to generate a token). So we need to be careful
    // to re-check the intended state of the socket
    // after a successful url generation
    const url = await this.#delegate.getUrl()

    // the we've been cleaned up while we were fetching
    // the URL, we can stop here
    if (this.#closed) return

    // if another call to createSocket happen to create
    // socket before we did then we can also bail here
    if (this.#socket) return

    // otherwise we have the URL so create the underlying
    // WebSocket instance
    const socket = new WebSocket(url)
    socket.binaryType = 'arraybuffer'
    socket.addEventListener('open', this.#handleOpen)
    socket.addEventListener('message', this.#handleMessage)
    socket.addEventListener('close', this.#handleClose)
    socket.addEventListener('error', this.#handleError)

    // save the socket on the instance
    this.#socket = socket
  }

  #handleOpen = () => {
    debug('ws opened')
    this.emit('open')
    clearTimeout(this.#openSuccessTimeout)
    // require socket to be held opne for a little time before
    // resetting the backoff algorithm
    this.#openSuccessTimeout = setTimeout(() => {
      debug('counting open as success')
      this.#attempts = 0
    }, 5 * 1000)
  }

  #handleAck = (ack) => {
    this.#lastMessageAck = ack
  }

  #handleMessage = (message) => {
    try {
      const { event, data, ack } = cborDecode(new Uint8Array(message.data))
      if (ack) return this.#handleAck(ack)
      if (!event) return console.error('Socket received message without event', message)
      return this.emit('event', event, data)
    } catch (e) {
      return console.error('Error processing message', message.data, e.stack)
    }
  }

  #reconnectDelay = (attempt) => {
    const randomFactor = 1 + (0.5 * Math.random())
    const delay = Math.floor(((300 * attempt) ** 1.2) * randomFactor)
    return Math.min(Math.max(this.#minDelay, delay), this.#maxDelay)
  }

  #reconnect = () => {
    // if the socket was destroyed then don't try to reconnect
    if (this.#closed) {
      debug('reconnect skipped as socket was closed')
      return
    }

    // never try to schedule multiple reconnects
    if (this.#reconnectTimeout) {
      debug('reconnect skipped as reconnect already scheduled')
      return
    }

    // if we're offline then don't try to reconnect yet, just wait a bit
    // and try again
    if (navigator.onLine === false) {
      debug('navigator offline')
      this.#reconnectTimeout = setTimeout(() => {
        this.#reconnectTimeout = null
        this.#reconnect()
      }, 1000)
      return
    }

    // otherwise work out the backoff delay and schedule reconnection
    const delay = this.#reconnectDelay(this.#attempts)
    debug('reconnecting in', delay, 'attempts', this.#attempts)
    this.#reconnectTimeout = setTimeout(async () => {
      this.#reconnectTimeout = null
      if (this.#closed) console.warn('tried to reconnect after close')
      else {
        this.#socket = null
        await this.#createSocket().catch(this.#handleError)
      }
    }, delay)
    this.#attempts += 1
  }

  #handleClose = () => {
    debug('ws closed')
    this.emit('close')

    debug('resetting message acks')
    this.#messageId = 0
    this.#lastMessageAck = 0

    // backoff reconnection
    if (!this.#closed) this.#reconnect()

    // cancel pending success timeout
    clearTimeout(this.#openSuccessTimeout)
  }

  #handleError = (error) => {
    this.emit('error', error)
  }

  #sendPing = () => {
    this.send('ping')
  }

  messageLag = () => {
    // if no ack received at all, then don't count as lagging
    // could mean server doesn't support acks or something
    if (!this.#lastMessageAck) return 0
    return this.#messageId - this.#lastMessageAck
  }

  setMaxReconnectDelay = (delay) => {
    debug('set max delay', delay)
    this.#maxDelay = delay
  }

  setMinReconnectDelay = (delay) => {
    debug('set min delay', delay)
    this.#minDelay = delay
  }

  send = (event, data) => {
    if (!this.connected) return false
    this.#messageId += 1
    this.#socket.send(cborEncode(data ? { event, id: this.#messageId, data } : { event }))
    return true
  }

  close = (...args) => {
    debug('close')
    this.#closed = true

    if (this.#socket) {
      try {
        this.#socket.close(...args)
      } catch (e) {
        debug('error closing socket', e)
      }
    }
    this.#socket = null
    this.removeAllListeners()
    clearTimeout(this.#reconnectTimeout)
    clearInterval(this.#pingInterval)
    if (typeof window !== 'undefined') window.removeEventListener('unload', this.close)
  }

  get bufferedAmount () {
    if (!this.#socket) return Infinity
    return this.#socket.bufferedAmount
  }

  get connected () {
    if (this.#socket) return this.#socket.readyState === this.#socket.OPEN
    else return false
  }
}
