import throttle from 'lodash/throttle.js'
import Debug from 'debug'
import { EventEmitter } from 'events'
import RESTAPI from './rest/RESTAPI.js'
import SocketManager from './socket/SocketManager.js'
import RemoteContext from './remotecontext/RemoteContext.js'
import ActivityDetection from './util/ActivityDetection.js'
import TokenExpiredError from './rest/TokenExpiredError.js'
import devices from './devices/index.js'
import sessions from './sessions/index.js'
import recordings from './recordings/index.js'
import users from './users/index.js'
import version from './version.js'

const debug = Debug('cbio.CobrowseAPI')

export default class CobrowseAPI extends EventEmitter {
  #activity = new ActivityDetection()

  #sockets = new SocketManager({ getSocketAuth: () => this.#getSocketAuth() })

  #api

  constructor (token, options = {}) {
    super()
    debug('constructed CobrowseAPI')
    this.#api = new RESTAPI(options.api ?? 'https://cobrowse.io')

    // headers for REST api calls
    this.#api.setHeader('X-CobrowsePlatform', 'agent-sdk')
    this.#api.setHeader('X-CobrowseSDKVersion', version)
    this.#api.setHeader('X-CobrowseAPIVersion', '1.2.0')

    if (this.#isBrowserContext) {
      // and some on sockets
      this.#sockets.setHeader('X-CobrowsePlatform', 'agent-sdk')
      this.#sockets.setHeader('X-CobrowseSDKVersion', version)
      this.#sockets.on('error', this.#handleError)
      this.#sockets.on('open', this.#handleSocketOpen)
    }

    if (token) this.token = token

    if (this.#isBrowserContext) {
      // watch for activity in the window, we only connect sockets when
      // windows are actually in use
      this.#activity.start()
      this.#activity.on('active', () => this.#sockets.connect().catch(this.#handleError))
      this.#activity.on('inactive', this.#sockets.disconnect)
    }
  }

  get #isBrowserContext () {
    return typeof window === 'object' && typeof document === 'object'
  }

  set token (token) {
    debug('updated token to', token)
    if (token) this.#api.setHeader('Authorization', `Bearer ${token}`)
    else this.#api.removeHeader('Authorization')

    // try to restart the activity loop if the token is updated
    // see the comment in #handleError for why this is
    if (this.#isBrowserContext) this.#activity.start()
  }

  get token () {
    const header = this.#api.getHeader('Authorization')
    if (!header) return null
    return header.replace(/^Bearer /, '')
  }

  set license (license) {
    if (license) this.#api.setHeader('X-CobrowseLicense', license)
    else this.#api.removeHeader('X-CobrowseLicense')
  }

  get license () {
    return this.#api.getHeader('X-CobrowseLicense')
  }

  get api () {
    return this.#api.baseurl
  }

  get devices () {
    return devices(this.#api, this.#sockets)
  }

  get sessions () {
    return sessions(this.#api, this.#sockets)
  }

  get recordings () {
    return recordings(this.#api)
  }

  get users () {
    return users(this.#api)
  }

  attachContext = async (target) => {
    if (this.#isBrowserContext) return new RemoteContext(target, this.#api, this.#sockets)
  }

  #getSocketAuth = throttle(async () => {
    // try to fetch an updated token for the socket connection
    // we use a token for the user to initally connect the socket,
    // we then add extra subscriptions to that socket as requried
    const user = await this.#api.fetch('/api/1/users/me')
    return {
      token: user.notification_token,
      url: user.notification_url
    }
  }, 60 * 60 * 1000)

  #handleSocketOpen = () => {
    this.emit('socket:open')
  }

  #handleError = (e) => {
    // if the JWT has expired, there's no point in keeping on trying
    // to connect the sockets, so kill the activity watching and socket
    // loop. We'll restart these if the token is updated
    if (e instanceof TokenExpiredError) {
      console.warn('The CobrowseIO token has expired. Please set a new token')
      if (this.#isBrowserContext) {
        this.#activity.stop()
        this.#sockets.disconnect()
      }
      this.emit('error', e)
    } else throw e
  }
}
