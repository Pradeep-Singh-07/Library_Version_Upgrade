import qs from 'qs'
import fetch from 'cross-fetch'
import TokenExpiredError from './TokenExpiredError.js'
import APIError from './APIError.js'

export default class RESTAPI {
  #baseurl

  #headers = {
    'Content-Type': 'application/json'
  }

  constructor (baseurl) {
    this.#baseurl = baseurl
  }

  setHeader = (key, value) => {
    this.#headers[key] = value
  }

  getHeader = (key) => {
    return this.#headers[key]
  }

  removeHeader = (key) => {
    delete this.#headers[key]
  }

  #url = (url, query) => {
    // ensure relative URLs are resolved from baseurl
    const absolute = new URL(url, this.#baseurl)
    // always set query params
    absolute.search = qs.stringify(query, { arrayFormat: 'brackets' })
    // strip trailing slashes
    if (/\/$/.test(absolute.pathname)) absolute.pathname = absolute.pathname.slice(0, -1)
    return absolute.toString()
  }

  get baseurl () {
    return this.#baseurl
  }

  create = async (url, state, query = {}, options = {}) => {
    const res = await fetch(this.#url(url, query), {
      method: 'POST',
      headers: this.#headers,
      body: JSON.stringify(state),
      ...options
    })
    await this.#handleErrors(res)
    return res.json()
  }

  list = async (url, query = {}, options = {}) => {
    const res = await fetch(this.#url(url, query), {
      method: 'GET',
      headers: this.#headers,
      ...options
    })
    await this.#handleErrors(res)
    const json = await res.json()
    if (!Array.isArray(json)) throw new Error('expected array')
    return json
  }

  fetch = async (url, state, query = {}, options = {}) => {
    const res = await fetch(this.#url(url, query), {
      method: 'GET',
      headers: this.#headers,
      ...options
    })
    await this.#handleErrors(res)
    return res.json()
  }

  update = async (url, state, query = {}, options = {}) => {
    const res = await fetch(this.#url(url, query), {
      method: 'PUT',
      headers: this.#headers,
      body: JSON.stringify(state),
      ...options
    })
    await this.#handleErrors(res)
    return res.json()
  }

  destroy = async (url, state, query = {}, options = {}) => {
    const res = await fetch(this.#url(url, query), {
      method: 'DELETE',
      headers: this.#headers,
      ...options
    })
    await this.#handleErrors(res)
    return {}
  }

  #handleErrors = async (res) => {
    if (res.status >= 400) {
      const err = await res.json()
      if (err.message === 'jwt expired') throw new TokenExpiredError(err.id, res.status, err.message)
      else throw new APIError(err.id, res.status, err.message)
    }
  }
}
