import { Observable } from 'rxjs';

/**
 * Determines the behavior when accepting an incoming call while there is
 * currently another active call.
 *
 * @public
 */
export declare enum AcceptIncomingCallBehavior {
    /**
     * Will put the currently active call on hold
     * before accepting the incoming call.
     */
    HOLD_CURRENT = "hold-current",
    /**
     * Will end the currently active call
     * before accepting the incoming call.
     */
    END_CURRENT = "end-current"
}

/**
 * Enables the creation of a device with call control functionality.
 *
 * A CallControlFactory is initialized by passing in softphone information and the
 * core {@link IApi} interface. It can then be used to create {@link ICallControl} instances.
 *
 * @public
 */
export declare class CallControlFactory {
    #private;
    constructor(coreApi: IApi);
    /**
     * Creates an {@link ICallControl} instance for a given device,
     * enabling call control functionality.
     *
     * @param device - the device you wish to execute call control functionality on.
     *
     * @returns an Observable which emits a new {@link ICallControl}.
     */
    createCallControl(device: IDevice): Promise<ICallControl>;
    /**
     * Verifies whether a device supports call control or not.
     *
     * @param potentialDevice - The device you wish to execute call control functionality on.
     *
     * @returns true if we find ANY descriptor which matches call control functionality, false otherwise.
     */
    supportsCallControl(potentialDevice: IDevice): boolean;
}

/**
 * Specifies how a specific connection
 * to a device is established.
 *
 * @public
 */
export declare enum ConnectionType {
    /** A direct, bluetooth connection. */
    BLUETOOTH = 0,
    /** An indirect connection via a parent device, such as dongle. */
    INDIRECT = 1,
    /** A direct, USB connection. */
    USB = 2
}

/**
 * The identifier of a single {@link IDevice}.
 *
 * @public
 */
export declare class DeviceId {
    /**
     * The ID of the device.
     */
    readonly id: string;
    constructor(
    /**
     * The ID of the device.
     */
    id: string);
    /**
     * Compares two IDs to verify whether or not they point at the same device.
     *
     * @remarks
     * In certain cases, the ID property differs but the two objects will point
     * at the same device.
     * For this reason, you must use the equals method instead of manually
     * comparing ID.
     *
     * @param that - the other device ID that you want to compare this one to.
     * @returns true if the two IDs point at the same device.
     */
    equals(that: DeviceId): boolean;
    startsWith(that: DeviceId): boolean;
    /**
     * Generates a string representation of the ID.
     * @returns a string representation of the ID.
     */
    toString(): string;
}

/**
 * Identifies the type of device,
 * e.g. whether a device is a headset, dongle, etc.
 *
 * @public
 */
export declare enum DeviceType {
    BASE = 0,
    HEADSET = 1,
    DESKSTAND = 2,
    OTHER = 3,
    DONGLE = 4,
    PC = 5,
    EHS = 6,
    USB = 7,
    SPEAKER_PHONE = 8,
    INDICATOR = 9,
    MOBILE = 10,
    NONE = 11,
    LOCAL = 12,
    DISPLAY = 13,
    HS_CRADLE = 14,
    HS_CRADLE2 = 15,
    MOBILE_IAP = 16,
    CRADLE = 17,
    VIDEO = 18,
    NOT_GN = 252,
    ANY_GN = 253,
    NOT_INIT = 254,
    ANY = 255
}

/**
 * Enables the creation of {@link ISingleCallControl} and {@link IMultiCallControl}
 * objects which offer easy call control functionality on a specific connection
 * that belongs on a specific device.
 *
 * @remarks
 * Compared to the regular Call Control module, Easy Call Control automates device signal handling and
 * command sequences.
 *
 * A CallControlFactory is initialized by passing in softphone information and the
 * core {@link IApi} interface. It can then be used to create {@link ICallControl} instances.
 *
 * @public
 */
export declare class EasyCallControlFactory {
    #private;
    constructor(coreApi: IApi);
    /**
     * Creates a device with single-call-control functionality.
     *
     * @param device - an SDK device from which the call-control device will be constructed.
     * @param initialState - An optional parameter, which sets the initial state of the created object. Use it when handling device changes.
     *
     * @returns a Promise which emits a new {@link ISingleCallControl}.
     *
     * @remarks
     * This is a simple interface only containing the basic functionality for handling easy
     * call control.
     *
     * If you wish to handle multiple calls and being able to set a call on hold, we advise you to
     * use the MultiCallControl interface instead - see method `createMultiCallControl`
     */
    createSingleCallControl(device: IDevice, initialState?: ISingleInitialState): Promise<ISingleCallControl>;
    /**
     * Creates a {@link IMultiCallControl} instance for a given device,
     * enabling multi-call-control functionality.
     *
     * @param device - an SDK device from which the call-control device will be constructed.
     * @param initialState - An optional parameter, which sets the initial state of the created object. Use it when handling device changes.
     *
     * @returns a Promise which emits a new {@link IMultiCallControl}.
     *
     * @remarks
     * This includes APIs for setting a device on hold and handle multiple ongoing calls.
     *
     * If you do not need to handle multiple ongoing calls, we advise you to use the SingleCallControl
     * interface instead - see method `createSingleCallControl`
     */
    createMultiCallControl(device: IDevice, initialState?: IMultiInitialState): Promise<IMultiCallControl>;
    /**
     * Verifies whether a device supports easy call control or not.
     *
     * @returns `true` if the device has a connection that has support
     * for any call control functionality, `false` otherwise.
     */
    supportsEasyCallControl(potentialDevice: IDevice): boolean;
    private getSharedDependencies;
}

/**
 * Determines what caused an error to be thrown.
 *
 * @public
 */
export declare enum ErrorType {
    /**
     * Specifies an error which is thrown when
     * events were not executed in the expected order,
     * e.g. trying to mute a device without having the call lock.
     *
     * These are usually fixable errors and happen due to control flow.
     */
    SDK_USAGE_ERROR = "sdk-usage-error",
    /**
     * Specifies an error which is thrown when
     * the specified command/feature is not supported by the device,
     * e.g. trying to mute a device that does not have a microphone.
     */
    FEATURE_NOT_SUPPORTED = "feature-not-supported",
    /**
     * Specifies an error which is thrown when
     * communicating with a Jabra device.
     *
     * This can happen due to several reasons,
     * e.g. device disconnected during packet transmission.
     *
     * Depending on the reason, this could either mean
     * that the operation is fatal or that it might work
     * if attempted again.
     */
    DEVICE_ERROR = "device-error",
    /**
     * Specifies an error which is thrown and
     * doesnâ€™t fall in any of the other categories.
     */
    UNEXPECTED_ERROR = "unexpected-error",
    /**
     * Specifies an error which is thrown due
     * to incorrect initialization.
     *
     * The user either has not installed the necessary components
     * (e.g. Chrome extension, console application),
     * or they have not provided correct arguments when
     * initializing the Jabra SDK
     * (e.g. missing/incomplete softphone information)
     */
    INIT_ERROR = "init-error"
}

/**
 * Determines the hold state of the device, for the current call.
 *
 * @public
 */
export declare enum HoldState {
    /**
     * The device assumes the current call is on hold.
     */
    ON_HOLD = "on-hold",
    /**
     * The device assumes the current call is not on hold,
     * i.e. is in progress.
     */
    NOT_ON_HOLD = "not-on-hold",
    /**
     * The device cannot be on hold,
     * as there are no active calls.
     */
    NO_ONGOING_CALLS = "no-ongoing-calls"
}

/**
 * Main Jabra API object.
 * Returned after SDK initialization (see {@link init}).
 *
 * Provides an entry point to reflecting and changing the state of Jabra devices.
 *
 * @public
 */
export declare interface IApi {
    /**
     * An observable which emits newly discovered Jabra devices.
     * The emitted device object can be consumed by the third party developer.
     * See {@link IDevice} for more information.
     */
    deviceAdded: Observable<IDevice>;
    /**
     * An observable which emits disconnected Jabra devices.
     * The emitted device object represents the device that has been disconnected.
     * See {@link IDevice} for more information.
     */
    deviceRemoved: Observable<IDevice>;
    /**
     * A list of connected physical Jabra devices.
     * Each device object can be consumed by the third party developer.
     * See {@link IDevice} for more information.
     */
    deviceList: Observable<IDevice[]>;
    /**
     * Returns the Jabra SDK version
     */
    getVersion(): string;
    /**
     * Get the Jabra Chromehost version
     *
     * Chromehost is the native console application communicating with the USB-layer.
     *
     * In node context, the Chromehost will be embedded in the jabra-js stack, and not something to be concerned with as an SDK-user.
     *
     * In browser context, the Chromehost is a required application that needs to be installed separately from this
     * npm-package - unless the library is configured to use WebHID-transport, see {@link IConfig.transport}.
     *
     * @returns The version number or null if not installed.
     */
    getChromehostVersion(): Promise<string | null>;
    /**
     * Get the Jabra Chrome Extension version
     *
     * In node context, the Chrome Extension is unnecessary and will always return null.
     *
     * In browser context, the Chrome Extension is a required component that needs to be installed separately from this
     * npm-package - unless the library is configured to use WebHID-transport, see {@link IConfig.transport}.
     *
     * @returns The version number or null if not installed.
     */
    getChromeExtensionVersion(): Promise<string | null>;
    /**
     * Get the underlying transport context.
     * Especially relevant when running in the browser to distinguish between
     * WebHID and Chrome Extension/Host
     * See enum {@link TransportContext}
     */
    transportContext: TransportContext;
    /**
     * The configuration that was used to initialize the SDK.
     */
    _config?: IConfig;
    /**
     * _Internal use only_.
     * Acts as a bridge between the SDK and the object which communicates with
     * the OS and the Jabra device.
     */
    _transport: ITransport;
    /**
     * Emits when the SDK has initialized and is ready for operation.
     * The observable will replay on new subscriptions.
     */
    _readyEvents: Observable<any>;
}

/**
 * Defines the necessary functionality for call control:
 * - being able to start/end a call,
 * - mute/unmute the microphone,
 * - hold/resume a call,
 * - start/stop the ringer on the device,
 * - events for emitted signals from the device, and
 * - the required call lock for executing all of these functions.
 *
 * @remarks
 * All of this functionality is associated with a single physical device.
 * For every connected Jabra headset, there is an additional instance of `ICallControl`
 * that is used to manipulate its call-related state and functionality.
 *
 * @public
 */
export declare interface ICallControl {
    /**
     * The single physical device with which the call control functionalities are
     * associated.
     */
    readonly device: IDevice;
    /**
     * Emits when the connection used for call control gets disconnected.
     */
    readonly onDisconnect: Observable<void>;
    /**
     * Observable for signals emitted by the device.
     *
     * Whenever the device sends a new signal,
     * this observable will be populated with {@link ICallControlSignal}
     * instances for each emission.
     *
     * @remarks
     * Reacting to incoming signals is an advanced topic.
     * Before implementing your solution, we urge you to check out the section
     * on Interacting with Jabra Devices in the
     * {@link https://developer.jabra.com/site/global/software/documentation/integrators-guide/interacting-with-devices.gsp
     * | Integrator's Guide}.
     *
     * @returns An observable that emits signals.
     */
    readonly deviceSignals: Observable<ICallControlSignal>;
    /**
     * Tries to acquire a call lock.
     * The call lock is a unique, per-device lock,
     * and is required to change the device state.
     * Acquiring a call lock must be the first step
     * in performing call control operations.
     *
     * @remarks
     * Acquiring a call lock can fail. This can happen for the following reasons:
     * * The device is call locked by another softphone using the Jabra SDK,
     *   resulting in `false` being returned.
     * * The device is call locked by another instance of your softphone implementation.
     *   This results in `false` being returned.
     * * You've already call locked the device (and therefore can proceed with any other functionality that requires the call lock).
     *   This results in an Exception being thrown
     *
     * @returns A Promise that resolves with `true` if the call lock is successfully acquired, `false` otherwise.
     *
     * @throws If you have already call locked the device.
     */
    takeCallLock(): Promise<boolean>;
    /**
     * Releases a previously acquired call lock.
     *
     * Releasing the call lock is the last step in
     * performing call control operations so remember
     * to execute it once you are done with the Jabra device.
     *
     * @throws If there is no active call lock imposed on the device by your softphone.
     */
    releaseCallLock(): void;
    /**
     * Informs the Jabra device that there's a change in the call status.
     *
     * @remarks
     * This controls if the device considers itself in an active call.
     * When offHook is true, a call is ongoing, otherwise there is no active call.
     *
     * @param isOffHook - The new offHook status of the device.
     * Use `true` when a call becomes active, regardless of call type (outgoing or incoming).
     * Use `false` when a call has ended and the device is no longer used.
     *
     * @throws If a call lock was not acquired prior to execution. See {@link ICallControl.takeCallLock} for more details.
     */
    offHook(isOffHook: boolean): void;
    /**
     * Starts or ends the "ring" effect on the Jabra device.
     * Used to indicate an incoming call.
     *
     * @param shouldRing - `true` to start the "ring" effect, `false` to stop it.
     *
     * @throws If a call lock was not acquired prior to execution. See {@link ICallControl.takeCallLock} for more details.
     */
    ring(shouldRing: boolean): void;
    /**
     * Mutes or unmutes the microphone of the Jabra device.
     *
     * @remarks
     * Should only be used during a call.
     *
     * @param shouldMute - `true` to mute the device, `false` to unmute it.
     *
     * @throws If a call lock was not acquired prior to execution. See {@link ICallControl.takeCallLock} for more details.
     */
    mute(shouldMute: boolean): void;
    /**
     * Tells the device whether an active call was put on hold
     * or a held up call was resumed.
     *
     * @param shouldHold - `true` when a call gets put on hold, `false` when it is resumed.
     *
     * @throws If a call lock was not acquired prior to execution. See {@link ICallControl.takeCallLock} for more details.
     */
    hold(shouldHold: boolean): void;
}

/**
 * Represents a signal that is emitted from a Jabra device.
 * These signals notify you that something has happened on the device.
 *
 * This could be:
 *
 * - the user expressing an intent to do something by interacting with the device (e.g. pressing a button).
 *
 * - acknowledgement to a request (e.g. a {@link SignalType | SignalType.HOOK_SWITCH} signal after your softphone starts a call successfully).
 *
 * - an error condition (e.g. headset out of range from the base station).
 *
 * @remarks
 * Reacting to incoming signals is an advanced topic.
 * Before implementing your solution, we urge you to check out the Integrator's guide.
 *
 * @public
 */
export declare interface ICallControlSignal {
    /**
     * The type of signal that was emitted by the device.
     */
    type: SignalType;
    /**
     * The signal's reported value.
     */
    value: boolean;
    /**
     * Describes the type of value for this signal. Can either be "relative" or "absolute".
     *
     * @remarks
     * Absolute:
     * Value will either be `0` or `1`.
     * `0` means `OFF` and `1` means `ON`.
     *
     * Relative:
     * Value will always be `1`.
     * For relative values the signal should be treated as a "toggle"
     * meaning the new state related to that signal is opposite
     * of the previous state (e.g. from `muted` to `unmuted`, from `unmuted` to `muted`).
     */
    valueType: ValueType;
    /**
     * Stringified version of the `ICallControlSignal` instance.
     */
    toString(): string;
}

/**
 * Optional configuration used when initializing the Jabra SDK.
 *
 * @remarks
 * In particular, the `IJabraConfig` object allows you to overwrite the
 * default message/warning/error logger with your own custom implementation.
 *
 * @public
 */
export declare interface IConfig {
    /**
     * This is used to uniquely identify a partner organization.
     * Partner keys can be obtained from the {@link https://developer.jabra.com | Jabra Developer Zone}.
     */
    partnerKey?: string;
    /**
     * Unique string identifier for your application.
     * You can choose whatever you like.
     * The ID must be between 3 and 100 characters long.
     * It can contain any combination of ASCII letters, numbers, dashes, and underscores.
     */
    appId?: string;
    /**
     * Provides a human-readable application name that shows when interacting with Jabra
     * applications and services. For example, the Preferred Softphone selector in Jabra Direct.
     *
     * The name must be no longer than 100 characters and can contain letters, numbers,
     * ampersands, dashes, and spaces. It must begin with a letter or number.
     */
    appName?: string;
    /**
     * The Jabra SDK can track usage and errors when allowed.
     * See {@link TrackingOptions} for available settings.
     *
     * Defaults to NO_TRACKING.
     */
    tracking?: TrackingOptions;
    /**
     * Implementation of the {@link ILogger} interface, used for logging runtime messages.
     * Can be a custom implementation depending on the user's needs.
     *
     * @remarks
     *
     * By default, the Jabra SDK logs messages as it executes its usual operations.
     * These log events can be intercepted by implementing the {@link ILogger} interface,
     * and providing your own custom functionality.
     *
     * For an example of how to do this, see the section 'Setting the library logging'
     * inside 'Initializing the core module' in the JavaScript Developer's Guide.
     */
    logger?: ILogger;
    /**
     * If set, this enables the SDK user to explicitly choose which transport
     * mechanism they would like to use.
     *
     * The options are to use the Chrome extension (default behaviour), Chrome extension but falling back
     * to WebHID if the extension is not available, or just WebHID.
     *
     * Currently the WebHID-standard is only available in Chromium based browsers and requires active
     * consent from the end-user.
     *
     * @remarks
     *
     * To collect user consent, import the webHidPairing function from main package and fire when end-user clicks
     * a relevant button in the UI (must be triggered by a user interaction - otherwise the request will be blocked).
     * The browser will show a list of connected Jabra devices and the user can choose what device to pair with.
     *
     * The browser caches consents for devices when paired - so this is only needed once per device.
     *
     * For an example of how to use this, see the 'Using WebHid' chapter
     * in the 'Initializing the Jabra library' section of the JavaScript
     * Developer's Guide.
     */
    transport?: RequestedBrowserTransport;

}

/**
 * Describes the properties of a physical connection that was
 * established between the system and a Jabra device.
 *
 * @public
 */
export declare interface IConnection {
    /**
     * Specifies the how the connection
     * was established, e.g. USB or Bluetooth.
     */
    readonly type: ConnectionType;
    /**
     * The unique ID of the connection.
     */
    readonly id: IConnectionId;
    /**
     * The {@link IHidChannel} object that
     * should be used to communicate with the device
     * when using ths connection.
     */
    readonly hidChannel: IHidChannel;
    /**
     * Optional parameter pointing at a parent connection
     * (if the current connection is established through such a parent connection),
     * e.g. a wireless connection through a Jabra dongle device.
     */
    readonly parentConnectionId?: IConnectionId;
    /**
     * Emits when this connection or its parent connection
     * (if one exists) gets disconnected.
     */
    readonly onDisconnect: Observable<void>;
}

/**
 * The identifier of a single {@link IConnection}.
 *
 * @public
 */
export declare interface IConnectionId {
    /**
     * Determines whether the connection is for a child or parent device.
     */
    readonly isChild: boolean;
    /**
     * Internal ID used for communication with the connection.
     */
    readonly transportId: TransportId;
    /**
     * Checks if another connection ID is equivalent to this one.
     *
     * @param that - another IConnectionID to test for equivalence.
     * @returns true if the connection IDs are equal, false if not
     */
    equals(that: IConnectionId): boolean;
    /**
     * Creates a string representation of the connection ID.
     *
     * @returns the connection ID as a string.
     */
    toString(): string;
}

/**
 * Console logging functionality.
 *
 * @public
 */
export declare interface IConsoleLogger {
    log: Observable<ILogEvent>;
}

/**
 * Describes all the properties of a physical Jabra device
 * along with methods for basic device communication via HID or GNP.
 *
 * @public
 */
export declare interface IDevice {
    /**
     * The ID of the device.
     *
     * @privateRemarks
     * \{vendorId\}:\{productId\}:\{serialNumber\}
     */
    id: DeviceId;
    /**
     * The name of the device,
     * e.g. "Jabra Evolve2 40".
     */
    name: string;
    /**
     * The vendor ID of the device.
     * Should be the Jabra vendor ID, i.e. 2830, or '0b0e'
     */
    vendorId: number;
    /**
     * The product ID of the device,
     * e.g. 3648, or '0e40' for Jabra Evolve2 40.
     */
    productId: number;
    /**
     * The serial number of the device.
     */
    serialNumber: string;
    /**
     * The device type,
     * e.g. headset, dongle, etc.
     */
    readonly type: DeviceType;
    /**
     * Retrieves the full access label of the device.
     * This is a stringified version of {@link IDevice.vendorId} and
     * {@link IDevice.productId}.
     *
     * @returns The label of the device,
     * e.g. '0b0e:0e40' for Jabra Evolve2 40.
     */
    readonly browserLabel: string;
    /**
     * An observable which emits whenever the device
     * receives a new connection that can be used
     * for communicating with the device.
     */
    connectionAdded: Observable<IConnection>;
    /**
     * An observable which emits whenever an
     * existing connection with the device has
     * disconnected. If it was the last existing
     * connection, {@link IDevice.onDisconnect} will
     * also emit.
     */
    connectionRemoved: Observable<IConnection>;
    /**
     * An observable which emits all existing connections
     * with a device whenever there are any changes with
     * a connection, whether it is a new one or a disconnected one.
     */
    connectionList: Observable<IConnection[]>;
    /**
     * Retrieves a list of the currently available connections.
     */
    currentConnections: IConnection[];
    /**
     * Emits when the device gets disconnected.
     */
    onDisconnect: Observable<void>;
}

/**
 * Base interface containing APIs
 * shared between {@link ISingleCallControl} and {@link IMultiCallControl}.
 *
 * @public
 */
export declare interface IEasyCallControlBase {
    /**
     * The single physical device to which the easy call control functionalities are associated to.
     */
    readonly device: IDevice;
    /**
     * Emits when the connection used for easy call control gets disconnected.
     *
     * @remarks
     * If this observable emits, the connection and thus the Easy Call Control instance can no longer be used.
     *
     * If this happens, for example, in the middle of a call, you can select a new device
     * (or the same device with another connection) and recover the state.
     * See {@link ISingleInitialState} or {@link IMultiInitialState} and for examples
     * refer to the 'Easy Call Control' chapter of the 'Managing Calls' section of the
     * JavaScript Developer's Guide.
     */
    readonly onDisconnect: Observable<void>;
    /**
     * Emits the ring state of the device whenever that state changes.
     *
     * @remarks
     * This can happen whenever a new incoming call is signalled,
     * and whenever that incoming call is accepted or rejected.
     */
    ringState: Observable<boolean>;
    /**
     * Emits the mute state of the device
     * whenever that state changes.
     *
     * @remarks
     * This can happen due to interaction with the device
     * (e.g. raising the boom arm) or due to interaction with
     * your softphone (e.g. pressing a mute button in the GUI).
     */
    muteState: Observable<MuteState>;
    /**
     * Sets the device into call state.
     *
     * @throws If the device is used by another softphone.
     */
    startCall(): Promise<void>;
    /**
     * Ends the current call.
     *
     * @throws If a call is not active.
     */
    endCall(): Promise<void>;
    /**
     * Signals that there is an incoming call.
     * The promise resolves only once the incoming call is either accepted or rejected.
     *
     * @remarks
     * On most devices, this starts the device ringer.
     *
     * @param ringTimeout - Optional parameter, determining
     * how long before the incoming call is automatically rejected due to a timeout.
     *
     * @returns `true` if the call was accepted, and `false` if rejected.
     *
     * @throws If the device is locked by another softphone.
     */
    signalIncomingCall(ringTimeout?: number): Promise<boolean>;
    /**
     * Rejects an incoming call.
     *
     * @remarks
     * The call can be rejected by the user by interacting with their device
     * or with your softphone.
     * In the first case, the incoming call will be automatically rejected
     * and {@link IEasyCallControlBase.signalIncomingCall} will resolve with `false`.
     * The second case requires your softphone to manually call this method,
     * before the incoming call is rejected and {@link IEasyCallControlBase.signalIncomingCall} is
     * resolved with `false`.
     *
     * @throws If an incoming call is not pending.
     */
    rejectIncomingCall(): void;
    /**
     * Mutes the device.
     *
     * @remarks
     * You can only change the mute state
     * while the device is in an active call.
     *
     * @throws If a call is not active.
     */
    mute(): Promise<void>;
    /**
     * Mute the device.
     *
     * @throws If a call is not active.
     *
     * @deprecated Return type has changed. Now it returns `Promise<void>` instead of `void`.
     * Nevertheless, the API will still work without awaiting.
     */
    mute(): void;
    /**
     * Unmutes the device.
     *
     * @remarks
     * You can only change the mute state
     * while the device is in an active call.
     *
     * @throws If a call is not active.
     */
    unmute(): void;
    /**
     * Teardown the Easy Call Control instance.
     *
     * All internal state subscriptions will be stopped to avoid potential memory leaks,
     * and the internal call lock will be released if taken.
     *
     * After using this method, you must create a new
     * Easy Call Control instance to continue usage.
     *
     * @remarks
     * Use this when you want to stop using the {@link ISingleCallControl} or
     * {@link IMultiCallControl} object but the connection to the device is
     * still active (e.g. when changing device or navigating between views).
     */
    teardown(): void;
}

/**
 * This is a wrapper for a stream of incoming
 * {@link IHidReport | IHidReports} from a device and a callback to output {@link IHidReport | IHidReports}
 * to the device.
 *
 * @remarks
 * Each instance of IHidChannel is associated with only one device,
 * and additionally, only one of its physical/wireless connections to the system.
 *
 * @public
 */
export declare interface IHidChannel {
    /**
     * Contains all of the {@link IHidUsage | IHidUsages} reported by the device upon device discovery.
     */
    readonly descriptor: IHidUsage[];
    /**
     * A continuous stream of incoming {@link IHidReport | IHidReports} from a device.
     */
    readonly input: Observable<IHidReport>;
    /**
     * Writes a {@link IHidReport} to the device.
     *
     * @param usagePage - The Usage Page of the report.
     * @param usage - The Usage of the report.
     * @param value - Values to send for that Usage and Usage Page.
     */
    output(usagePage: number, usage: number, value: number | number[]): void;
    /**
     * Returns a feature {@link IHidReport} from the device.
     *
     * @param usagePage - The Usage Page of the feature report.
     * @param usage - The Usage of the report.
     *
     * @returns The current value of the feature.
     */
    getFeatureReport(usagePage: number, usage: number): Observable<number>;
    /**
     * Writes a feature {@link IHidReport} to the device.
     *
     * @param usagePage - The Usage Page of the feature report.
     * @param usage - The Usage of the report.
     * @param value - The new value of that feature.
     */
    setFeatureReport(usagePage: number, usage: number, value: number | number[]): void;

}

/**
 * HID report coming from a Jabra Sdk device.
 *
 * @remarks
 * See {@link https://usb.org} for more information on the HID specifications.
 *
 * @public
 */
export declare interface IHidReport {
    /**
     * The ID of the device which sent the report.
     */
    id: DeviceId;
    /**
     * The HID usage page of the report.
     */
    usagePage: number;
    /**
     * The HID usage ID of the report.
     */
    usage: number;
    /**
     * The values of the report.
     */
    value: number | number[];
    /**
     * Indicates if the values of the report come as an array or not.
     *
     * @returns
     * true if the values are an array, false if just a single value
     */
    isArray(): boolean;
}

/**
 * HID Usage.
 *
 * @public
 */
export declare interface IHidUsage {
    /**
     * The type of reports offered by the usage.
     */
    usagePage: number;
    /**
     * The usage ID of the usage.
     */
    usage: number;
    /**
     * The type of reports offered by the usage.
     */
    reportType: ReportType;
    /**
     * The type of values that the usage will report or use.
     */
    valueType: ValueType;
    /**
     * The maximum size of a single report for this usage.
     */
    reportSize: number;
}

/**
 * Describes an error that can be thrown while
 * utilizing the Jabra SDK.
 *
 * It has the usual properties of an `Error`,
 * with some additional ones added.
 *
 * @public
 */
export declare interface IJabraError extends Error {
    /**
     * Error reason, e.g. unsupported feature.
     */
    readonly type: ErrorType;
}

/**
 * Describes all necessary information about a log event.
 *
 * @public
 */
export declare interface ILogEvent {
    /**
     * The severity of the log event, e.g. error or warning. See {@link LogLevel}.
     */
    level: LogLevel;
    /**
     * The stack layer where the log event occurred, e.g. inside the Chrome extension.
     * See {@link StackLayer}.
     */
    layer: StackLayer;
    /**
     * Text message that will be logged.
     */
    message: string;
}

/**
 * Interface used to describe an object that can log runtime information.
 *
 * @public
 */
export declare interface ILogger {
    /**
     * Logs a message based on an event that triggered during runtime operations.
     *
     * @param event - Event that should be logged. Includes message, logging level and message.
     * See {@link ILogEvent} for more information.
     */
    write(event: ILogEvent): void;
}

/**
 * Defines the necessary functionality for easy call control, when handling multiple calls.
 *
 * This functionality includes:
 * - being able to start an outgoing call,
 * - signaling an incoming call, answer and reject it,
 * - mute/unmute the microphone,
 * - subscribing to device events,
 * - ending a call, and
 * - holding/resuming/swapping a call (unlike {@link ISingleCallControl}).
 *
 * @remarks
 * All of this functionality is associated with a single physical device.
 * For every connected Jabra headset, there is an additional instance of {@link IEasyCallControlBase}
 * that is used to manipulate its call-related state and functionality.
 *
 * @public
 */
export declare interface IMultiCallControl extends IEasyCallControlBase {
    /**
     * Emits the number of calls currently in progress.
     *
     * `0` means that the device is idle with no calls in progress,
     * while `1` or more signifies the number of calls currently active.
     *
     * Starting a new call - or accepting an incoming call - will increment this counter.
     * Similarly, ending a call will decrement the count until it reaches 0.
     *
     * @remarks
     * To handle multiple-call scenarios, ensure
     * you keep your application's list of ongoing calls
     * in sync with this count.
     *
     * To handle one active call at a time, do one of the following:
     * - treat this value as an ON-OFF toggle,
     * - optionally throw an error if the count
     * increases to more than 1, which would mean something went wrong in
     * the application logic, or
     * - use {@link ISingleCallControl} instead.
     */
    ongoingCalls: Observable<number>;
    /**
     * Emits the hold state of the device
     * whenever that state changes.
     *
     * @remarks
     * This can happen due to interaction with the device
     * (the hold command can differ between devices, but is often triggered by long-pressing the start/end-call button)
     * or due to interaction with your softphone (e.g. pressing a hold button in the GUI).
     */
    holdState: Observable<HoldState>;
    /**
     * Emits whenever swap request is triggered.
     *
     * This can happen due to interaction with the device (most often the same button that triggers hold)
     * or due to interaction with your softphone (e.g. pressing a swap button in the GUI).
     *
     * @remarks
     * The observable does not emit any value, and it does not keep track of what call was swapped
     * to or from - this should be handled by the softphone application.
     *
     * The most common implementation pattern would be to maintain a list of ongoing calls in the
     * softphone application. Then, whenever swap is triggered, the active call is moved to the
     * next call in line.
     */
    swapRequest: Observable<undefined>;
    /**
     * Accepts an incoming call and sets the device into call state.
     *
     * @throws If an incoming call is not pending.
     *
     * @param behavior - Optionally controls the behavior when accepting an incoming call, defaults to END_CURRENT
     *
     * @remarks
     * Accepting an incoming call behaves differently whether called from idle (1) or while another call is active (2).
     *
     * 1) From idle: the device is simply set into call state and the call counter is increased by one.
     * 2) While another call is active: depends on the behavior parameter. It can either be to end the current call and
     * start a new call (default), or hold the current call and start a new call.
     */
    acceptIncomingCall(behavior?: AcceptIncomingCallBehavior): Promise<void>;
    /**
     * Sets the current call on hold.
     *
     * @remarks
     * You can only change the hold state
     * while the device is in an active call.
     *
     * @throws If a call is not active.
     */
    hold(): Promise<void>;
    /**
     * Resumes the current call when on hold.
     *
     * @remarks
     * You can only change the hold state
     * while the device is in an active call.
     *
     * @throws If a call is not active, or if no call is on hold.
     */
    resume(): Promise<void>;
}

/**
 * Optional initial state for {@link IMultiCallControl}.
 *
 * Used to set the initial state if the device was changed in the middle of a call,
 * or to recover the state after device disconnections.
 *
 * @public
 */
export declare interface IMultiInitialState {
    /**
     * Determines the number of ongoing calls at the time of initialization.
     * When set to `0`, no ongoing calls are happening.
     *
     * @remarks
     * If set to `0`, subsequent arguments for {@link IMultiInitialState.muted} and {@link IMultiInitialState.onHold}
     * will be ignored (setting mute or hold state on an idle device is not supported).
     */
    ongoingCalls: number;
    /**
     * `true` to mute the device and `false` to unmute.
     *
     * @remarks
     * Can only be set to `true` if {@link IMultiInitialState.ongoingCalls} is a positive integer (greater than zero).
     */
    muted?: boolean;
    /**
     * `true` to hold the device and `false` to not hold the device.
     *
     * @remarks
     * Can only be set to `true` if {@link IMultiInitialState.ongoingCalls} is a positive integer (greater than zero).
     */
    onHold?: boolean;
}

/**
 * Initialize the Jabra SDK.
 * Entry point to being able to control Jabra hardware.
 *
 * @param config - Optional configuration settings. See {@link IConfig} for more details.
 *
 * @returns The initialized SDK object, which can be used to control Jabra hardware.
 *
 * @throws If the underlying transport object (console-app or Chrome extension)
 * fails to connect for some reason, e.g. when it's not installed on the system.
 *
 * @public
 */
export declare function init(config: IConfig | undefined): Promise<IApi>;

/**
 * Defines the necessary functionality for easy call control, when handling only one call at a time.
 *
 * This functionality includes:
 * - being able to start an outgoing call,
 * - signaling incoming call, answer and reject it,
 * - mute/unmute the microphone,
 * - subscribing to device events,
 * - ending a call.
 *
 * @remarks
 * All of this functionality is associated with a single physical device.
 * For every connected Jabra headset, there is an additional instance of {@link IEasyCallControlBase}
 * that is used to manipulate its call-related state and functionality.
 *
 * @public
 */
export declare interface ISingleCallControl extends IEasyCallControlBase {
    /**
     * Emits a boolean signifying if the device is in call state or not.
     */
    callActive: Observable<boolean>;
    /**
     * Accepts an incoming call and sets the device into call state.
     *
     * @remarks
     * If there is already an active call, it will be ended before accepting the incoming call.
     *
     * The call can be accepted by the user by interacting with their device
     * or with your softphone.
     * In the first case, the incoming call will be automatically accepted
     * and {@link IEasyCallControlBase.signalIncomingCall} will resolve with `true`.
     * The second case requires your softphone to manually call this method,
     * before the incoming call is accepted and {@link IEasyCallControlBase.signalIncomingCall} is
     * resolved with `true`.
     *
     * @throws If an incoming call is not pending.
     *
     */
    acceptIncomingCall(): Promise<void>;
}

/**
 * Optional initial state for {@link ISingleCallControl}.
 *
 * Used to set the initial state if the device was changed in the middle of a call,
 * or to recover the state after device disconnections.
 *
 * @public
 */
export declare interface ISingleInitialState {
    /**
     * Set to `true` to set device into a in-call state.
     *
     * @remarks
     * If set to false, the subsequent argument for {@link ISingleInitialState.muted}
     * will be ignored (setting mute state on an idle device is not supported).
     */
    callActive: boolean;
    /**
     * `true` to mute the device and `false` to unmute.
     *
     * @remarks
     * Can only be set to `true` if {@link ISingleInitialState.callActive} is also set to `true`.
     */
    muted?: boolean;
}

/**
 * @privateRemarks
 *
 * Interface describing the required functionality for
 * sending and receiving messages to/from the Low-level USB HID Layer (layer 5).
 *
 * The implementing `ITransport` object acts as a bridge between
 * the rest of the SDK and the object which communicates
 * with the OS and the Jabra hardware.
 *
 * @public
 */
export declare interface ITransport {
    /**
     *
     */
    context: TransportContext;
    /**
     * @privateRemarks
     * Connect the to the underlying component/layer.
     *
     * Depending on the implementation, this could be
     * launching the console app or launching the
     * Chrome extension (when running in a browser).
     *
     * @returns A Promise which completes successfully
     * once the console-app or the Chrome extension responds, i.e.
     * gets connected.
     *
     * @throws If the console-app or Chrome extension fails to respond,
     * which usually happens because one of them is not installed.
     */
    connect(): Promise<void>;
    /**
     * @privateRemarks
     *
     * Observable for incoming console app events.
     *
     * Whenever the console app (or the Chrome extension)
     * send a message intended for the SDK,
     * this event will be triggered with the message
     * inside of it.
     */
    consoleAppEvent: Observable<any>;
    /**
     * @privateRemarks
     *
     * Write an action to the console app.
     *
     * Usually this would be an instruction to change
     * a headset's state or to acquire/release a lock.
     *
     * @param action - Action object to be sent to the console app.
     */
    writeAction(action: any): void;
}

/**
 * Device object returned by the WebHID consent dialogue
 *
 * @public
 */
export declare interface IWebHidDevice {
    /** Unique device ID generated by the browser. Will reset on every refresh */
    sessionId: string;
    /** Name of the Jabra product */
    productName: string;
    /** Jabra product ID */
    productId: number;
    /** Jabra organization ID */
    vendorId: number;
}

/**
 * Implementation of {@link IJabraError} interface
 * which extends the base `Error` class by
 * adding an {@link ErrorType} property.
 *
 * @public
 */
export declare class JabraError extends Error implements IJabraError {
    readonly type: ErrorType;
    constructor(message: string, type: ErrorType);
}

/**
 * Error severity of a log, i.e. whether a log event is due
 * to an exception, warning, or just an info message.
 * See {@link ILogEvent} for more information.
 *
 * @public
 */
export declare enum LogLevel {
    /**
     * Used when the reason for the log event can be regarded as an error.
     */
    ERROR = "error",
    /**
     * Used when the user is warned that something might have gone wrong (but not necessarily).
     */
    WARNING = "warning",
    /**
     * Used to log messages related to normal execution.
     */
    INFO = "info"
}

/**
 * Determines the mute state of the device, for the current call.
 *
 * @public
 */
export declare enum MuteState {
    /**
     * The device is muted.
     */
    MUTED = "muted",
    /**
     * The device is unmuted.
     */
    UNMUTED = "unmuted",
    /**
     * The device cannot be muted or unmuted,
     * as there are no ongoing calls right now.
     */
    NO_ONGOING_CALLS = "no-ongoing-calls"
}

/**
 * The type of reports offered by the usage.
 *
 * @public
 */
export declare enum ReportType {
    INPUT = 0,
    OUTPUT = 1,
    FEATURE = 2
}

/**
 * Optional transport modes that can be requested on initialisation. These are relevant when
 * operating within a browser context only. They are not used outside of a browser, where Node
 * is used instead.
 *
 * @public
 */
export declare enum RequestedBrowserTransport {
    CHROME_EXTENSION = "chrome-extension",
    WEB_HID = "web-hid",
    CHROME_EXTENSION_WITH_WEB_HID_FALLBACK = "chrome-extension-with-web-hid-fallback"
}

/**
 * Definitions for incoming signals from Jabra devices
 * related to call control.
 *
 * @remarks
 * This list might not be exhaustive.
 *
 * There is a known issue with `PHONE_KEY` signals
 * when using the SDK on Mac OS or Linux
 * and running {@link TransportContext | TransportContext.NODE}.
 *
 * @public
 */
export declare enum SignalType {
    /**
     * The signal is reported in multiple scenarios:
     *
     * - as an acknowledgement of a successful {@link ICallControl.offHook | ICallControl.offHook(true)} request made by your softphone,
     *
     * - when the user is trying to accept an incoming call by interacting with the device, or
     *
     * - when the user is trying to start a new outgoing call by interacting with the device.
     *
     */
    HOOK_SWITCH = 32,
    /**
     * Emitted if calling offHook(true) while the device is already in
     * call state
     */
    GN_PSEUDO_HOOK_SWITCH = 65531,
    /**
     * This signal is reported in multiple scenarios:
     *
     * - when the user requests to hold a call by interacting with the device,
     *
     * - when the user requests to resume a call by interacting with the device, or
     *
     * - when the user requests to swap the 'active' call (if there's multiple calls running on their system).
     */
    FLASH = 33,
    /**
     * Indicates whether a call is on hold.
     *
     * `1` means there is a call on hold, while
     * `0` means there is no call on hold.
     *
     */
    ALT_HOLD = 35,
    /**
     * Indicates that the user requests the softphone to repeat the most recent call.
     */
    REDIAL = 36,
    /**
     * This signal is reported by wireless adapters (Bluetooth and DECT).
     * It gives information on whether the adapter is transmitting audio
     * to a connected device (`true`) or if the device is in power saving mode instead.
     *
     * If the device is saving power, short audio cues might be cut off,
     * as there is some latency before the device wakes up and
     * re-establishes wireless audio link to the adapter.
     */
    ONLINE = 42,
    /**
     * This command is used to switch from headset to speaker phone
     * and from speaker phone to headset (for applicable devices).
     */
    SPEAKER_PHONE = 43,
    /**
     * Indicates a change in the mute state of the microphone.
     */
    PHONE_MUTE = 47,
    /**
     * This indicates that the user has completed entering digits
     * and is ready to begin routing the phone call.
     *
     * @remarks
     * Note that this feature will not be used to alternate line
     * selection as this is the functionality of {@link SignalType.FLASH}.
     * It should not be used to end the call either, as this is the function of {@link SignalType.HOOK_SWITCH}.
     */
    SEND = 49,
    /**
     * Indicates that a speed dial operation is initiating.
     */
    SPEED_DIAL = 80,
    /**
     * Enters voice mail application.
     */
    VOICE_MAIL = 112,
    /**
     * Toggles answering machine operation.
     */
    ANSWER_ON_OFF = 116,
    /**
     * Indicates whether the device is currently in an active call (`true`) or not (`false`).
     *
     * The value of the signal is not exclusive to your softphone,
     * and will also be sent from the device when other softphones
     * start a call.
     */
    LINE_BUSY = 151,
    /**
     * Indicates a change in the status of incoming calls.
     * @remarks
     * `1` indicates there is an incoming call, and that there is a ring effect active.
     * The effect remains active until the software negates the control to stop the effect.
     * `0` indicates any previous incoming calls have stopped, along with any associated ring effects.
     */
    RINGER = 158,
    /**
     * Indicates that the number pad "0" button was pressed.
     */
    PHONE_KEY_0 = 176,
    /**
     * Indicates that the number pad "1" button was pressed.
     */
    PHONE_KEY_1 = 177,
    /**
     * Indicates that the number pad "2" button was pressed.
     */
    PHONE_KEY_2 = 178,
    /**
     * Indicates that the number pad "3" button was pressed.
     */
    PHONE_KEY_3 = 179,
    /**
     * Indicates that the number pad "4" button was pressed.
     */
    PHONE_KEY_4 = 180,
    /**
     * Indicates that the number pad "5" button was pressed.
     */
    PHONE_KEY_5 = 181,
    /**
     * Indicates that the number pad "6" button was pressed.
     */
    PHONE_KEY_6 = 182,
    /**
     * Indicates that the number pad "7" button was pressed.
     */
    PHONE_KEY_7 = 183,
    /**
     * Indicates that the number pad "8" button was pressed.
     */
    PHONE_KEY_8 = 184,
    /**
     * Indicates that the number pad "9" button was pressed.
     */
    PHONE_KEY_9 = 185,
    /**
     * Indicates that the number pad "*" button was pressed.
     */
    PHONE_KEY_STAR = 186,
    /**
     * Indicates that the number pad "#" button was pressed.
     */
    PHONE_KEY_POUND = 187,
    /**
     * Indicates that the "volume up" button was pressed.
     *
     * @remarks
     * On Windows, the system's volume level will automatically
     * adjust as the button gets pressed.
     */
    ALT_VOLUME_UP = 233,
    /**
     * Indicates that the "volume down" button was pressed.
     *
     * @remarks
     * On Windows, the system's volume level will automatically
     * adjust as the button gets pressed.
     */
    ALT_VOLUME_DOWN = 234,
    /**
     * Indicates that the user requests to reject an incoming call.
     */
    REJECT_CALL = 65533
}

/**
 * The stack layer in which the log event occurred,
 * i.e. which module caused the {@link ILogEvent}.
 *
 * @public
 */
export declare enum StackLayer {
    /**
     * The log event was triggered by the Chrome extension.
     */
    CHROME_EXTENSION = "chrome-extension",
    /**
     * The log event was triggered by the native console app (i.e. the low level USB HID layer).
     */
    NATIVE_CONSOLE = "native-console",
    /**
     * The log event was triggered by the JavaScript SDK.
     */
    JS_LIB = "js-lib"
}

/**
 * Used by {@link IConfig.tracking} to determine the level of allowed
 * tracking of Jabra library usage and errors - defaults to NO_TRACKING.
 *
 * @public
 */
export declare enum TrackingOptions {
    /** No tracking will be enabled. */
    NO_TRACKING = "no-tracking",
    /** Only errors that occur during library usage will be tracked. */
    TRACK_ERRORS = "track-errors",
    /** Only library usage will be tracked. */
    TRACK_USAGE = "track-usage",
    /** All possible tracking is enabled. */
    TRACK_ALL = "track-all"
}

/**
 * Transport context to determine what mechanism is used to communicate with connected devices
 *
 * @public
 */
export declare enum TransportContext {
    NODE = "node",
    CHROME_EXTENSION = "chrome-extension",
    WEB_HID = "web-hid"
}

/**
 * The ID used by the PC to communicate with this device.
 *
 * @public
 */
export declare type TransportId = string;

/**
 * The type of values that the usage will report or use
 *
 * @public
 */
export declare enum ValueType {
    ABSOLUTE = "absolute",
    RELATIVE = "relative"
}

/**
 * Triggers WebHID consent dialogue in compatible browsers
 *
 * For an example of how to use this, see the 'Using WebHid' chapter
 * in the 'Initializing the Jabra library' section of the JavaScript
 * Developer's Guide.
 *
 * @returns - A list of allowed devices. The API will return an empty list if the user presses cancel.
 *
 * @public
 */
export declare function webHidPairing(): Promise<IWebHidDevice[]>;

export { }
