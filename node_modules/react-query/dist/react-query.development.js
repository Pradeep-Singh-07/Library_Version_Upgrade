(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactQuery = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  // The tuple variants are only to infer types in the public API

  (function (QueryStatus) {
    QueryStatus["Idle"] = "idle";
    QueryStatus["Loading"] = "loading";
    QueryStatus["Error"] = "error";
    QueryStatus["Success"] = "success";
  })(exports.QueryStatus || (exports.QueryStatus = {}));

  // UTILS
  var _uid = 0;
  var uid = function uid() {
    return _uid++;
  };
  var cancelledError = {};
  var isServer = typeof window === 'undefined';
  function noop() {
    return void 0;
  }
  var Console = console || {
    error: noop,
    warn: noop,
    log: noop
  };
  function setConsole(c) {
    Console = c;
  }
  function functionalUpdate(updater, input) {
    return typeof updater === 'function' ? updater(input) : updater;
  }

  function stableStringifyReplacer(_key, value) {
    if (typeof value === 'function') {
      throw new Error('Cannot stringify non JSON value');
    }

    if (isObject(value)) {
      return Object.keys(value).sort().reduce(function (result, key) {
        result[key] = value[key];
        return result;
      }, {});
    }

    return value;
  }

  function stableStringify(value) {
    return JSON.stringify(value, stableStringifyReplacer);
  }
  function deepIncludes(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a !== typeof b) {
      return false;
    }

    if (typeof a === 'object') {
      return !Object.keys(b).some(function (key) {
        return !deepIncludes(a[key], b[key]);
      });
    }

    return false;
  }
  function isDocumentVisible() {
    // document global can be unavailable in react native
    if (typeof document === 'undefined') {
      return true;
    }

    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);
  }
  function isOnline() {
    return navigator.onLine === undefined || navigator.onLine;
  }
  function getQueryArgs(args) {
    var queryKey;
    var queryFn;
    var config;
    var options;

    if (isObject(args[0])) {
      queryKey = args[0].queryKey;
      queryFn = args[0].queryFn;
      config = args[0].config;
      options = args[1];
    } else if (isObject(args[1])) {
      queryKey = args[0];
      config = args[1];
      options = args[2];
    } else {
      queryKey = args[0];
      queryFn = args[1];
      config = args[2];
      options = args[3];
    }

    config = config ? _extends({
      queryKey: queryKey
    }, config) : {
      queryKey: queryKey
    };

    if (queryFn) {
      config = _extends({}, config, {
        queryFn: queryFn
      });
    }

    return [queryKey, config, options];
  }
  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */

  function replaceEqualDeep(a, b) {
    if (a === b) {
      return a;
    }

    var array = Array.isArray(a) && Array.isArray(b);

    if (array || isPlainObject(a) && isPlainObject(b)) {
      var aSize = array ? a.length : Object.keys(a).length;
      var bItems = array ? b : Object.keys(b);
      var bSize = bItems.length;
      var copy = array ? [] : {};
      var equalItems = 0;

      for (var i = 0; i < bSize; i++) {
        var key = array ? i : bItems[i];
        copy[key] = replaceEqualDeep(a[key], b[key]);

        if (copy[key] === a[key]) {
          equalItems++;
        }
      }

      return aSize === bSize && equalItems === aSize ? a : copy;
    }

    return b;
  }
  function isObject(a) {
    return a && typeof a === 'object' && !Array.isArray(a);
  } // Copied from: https://github.com/jonschlinkert/is-plain-object

  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    } // If has modified constructor


    var ctor = o.constructor;

    if (typeof ctor === 'undefined') {
      return true;
    } // If has modified prototype


    var prot = ctor.prototype;

    if (!hasObjectPrototype(prot)) {
      return false;
    } // If constructor does not have an Object-specific method


    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    } // Most likely a plain Object


    return true;
  }

  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  function getStatusProps(status) {
    return {
      status: status,
      isLoading: status === exports.QueryStatus.Loading,
      isSuccess: status === exports.QueryStatus.Success,
      isError: status === exports.QueryStatus.Error,
      isIdle: status === exports.QueryStatus.Idle
    };
  }

  // CONFIG
  var defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {
    try {
      var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];
      var queryHash = stableStringify(arrayQueryKey);
      arrayQueryKey = JSON.parse(queryHash);
      return [queryHash, arrayQueryKey];
    } catch (_unused) {
      throw new Error('A valid query key is required!');
    }
  };
  /**
   * Config merging strategy
   *
   * When using hooks the config will be merged in the following order:
   *
   * 1. These defaults.
   * 2. Defaults from the hook query cache.
   * 3. Combined defaults from any config providers in the tree.
   * 4. Query/mutation config provided to the hook.
   *
   * When using a query cache directly the config will be merged in the following order:
   *
   * 1. These defaults.
   * 2. Defaults from the query cache.
   * 3. Query/mutation config provided to the query cache method.
   */

  var DEFAULT_CONFIG = {
    queries: {
      queryKeySerializerFn: defaultQueryKeySerializerFn,
      enabled: true,
      retry: 3,
      retryDelay: function retryDelay(attemptIndex) {
        return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
      },
      staleTime: 0,
      cacheTime: 5 * 60 * 1000,
      refetchOnWindowFocus: true,
      refetchOnMount: true
    }
  };
  function mergeReactQueryConfigs(a, b) {
    return {
      shared: _extends({}, a.shared, b.shared),
      queries: _extends({}, a.queries, b.queries),
      mutations: _extends({}, a.mutations, b.mutations)
    };
  }
  function getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, configOverrides) {
    return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.queries, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.queries, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.queries, config, configOverrides);
  }
  function getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, configOverrides) {
    return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.mutations, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.mutations, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.mutations, config, configOverrides);
  }

  var QueryObserver = /*#__PURE__*/function () {
    function QueryObserver(config) {
      this.config = config; // Bind exposed methods

      this.clear = this.clear.bind(this);
      this.refetch = this.refetch.bind(this);
      this.fetchMore = this.fetchMore.bind(this); // Subscribe to the query

      this.updateQuery();
    }

    var _proto = QueryObserver.prototype;

    _proto.subscribe = function subscribe(listener) {
      this.started = true;
      this.updateListener = listener;
      this.currentQuery.subscribeObserver(this);
      this.optionalFetch();
      this.updateRefetchInterval();
      return this.unsubscribe.bind(this);
    };

    _proto.unsubscribe = function unsubscribe(preventGC) {
      this.started = false;
      this.updateListener = undefined;
      this.clearRefetchInterval();
      this.currentQuery.unsubscribeObserver(this, preventGC);
    };

    _proto.updateConfig = function updateConfig(config) {
      var prevConfig = this.config;
      this.config = config;
      var updated = this.updateQuery(); // Take no further actions if the observer did not start yet

      if (!this.started) {
        return;
      } // If we subscribed to a new query, optionally fetch and update refetch


      if (updated) {
        this.optionalFetch();
        this.updateRefetchInterval();
        return;
      } // Optionally fetch if the query became enabled


      if (config.enabled && !prevConfig.enabled) {
        this.optionalFetch();
      } // Update refetch interval if needed


      if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval || config.refetchIntervalInBackground !== prevConfig.refetchIntervalInBackground) {
        this.updateRefetchInterval();
      }
    };

    _proto.getCurrentResult = function getCurrentResult() {
      return this.currentResult;
    };

    _proto.clear = function clear() {
      return this.currentQuery.clear();
    };

    _proto.refetch = function refetch() {
      try {
        var _this2 = this;

        _this2.currentQuery.updateConfig(_this2.config);

        return _this2.currentQuery.refetch();
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {
      try {
        var _this4 = this;

        _this4.currentQuery.updateConfig(_this4.config);

        return _this4.currentQuery.fetchMore(fetchMoreVariable, options);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetch = function fetch() {
      try {
        var _this6 = this;

        _this6.currentQuery.updateConfig(_this6.config);

        return _this6.currentQuery.fetch().catch(function (error) {
          Console.error(error);
          return undefined;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.optionalFetch = function optionalFetch() {
      if (this.config.enabled && // Don't auto refetch if disabled
      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched
      this.currentResult.isStale && ( // Only refetch if stale
      this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {
        this.fetch();
      }
    };

    _proto.updateRefetchInterval = function updateRefetchInterval() {
      var _this7 = this;

      if (isServer) {
        return;
      }

      this.clearRefetchInterval();

      if (!this.config.enabled || !this.config.refetchInterval || this.config.refetchInterval < 0 || this.config.refetchInterval === Infinity) {
        return;
      }

      this.refetchIntervalId = setInterval(function () {
        if (_this7.config.refetchIntervalInBackground || isDocumentVisible()) {
          _this7.fetch();
        }
      }, this.config.refetchInterval);
    };

    _proto.clearRefetchInterval = function clearRefetchInterval() {
      if (this.refetchIntervalId) {
        clearInterval(this.refetchIntervalId);
        this.refetchIntervalId = undefined;
      }
    };

    _proto.createResult = function createResult() {
      var currentQuery = this.currentQuery,
          previousResult = this.previousResult,
          config = this.config;
      var _currentQuery$state = currentQuery.state,
          canFetchMore = _currentQuery$state.canFetchMore,
          error = _currentQuery$state.error,
          failureCount = _currentQuery$state.failureCount,
          isFetched = _currentQuery$state.isFetched,
          isFetching = _currentQuery$state.isFetching,
          isFetchingMore = _currentQuery$state.isFetchingMore,
          isLoading = _currentQuery$state.isLoading,
          isStale = _currentQuery$state.isStale;
      var _currentQuery$state2 = currentQuery.state,
          data = _currentQuery$state2.data,
          status = _currentQuery$state2.status,
          updatedAt = _currentQuery$state2.updatedAt; // Keep previous data if needed

      if (config.keepPreviousData && isLoading && (previousResult == null ? void 0 : previousResult.isSuccess)) {
        data = previousResult.data;
        updatedAt = previousResult.updatedAt;
        status = previousResult.status;
      }

      return _extends({}, getStatusProps(status), {
        canFetchMore: canFetchMore,
        clear: this.clear,
        data: data,
        error: error,
        failureCount: failureCount,
        fetchMore: this.fetchMore,
        isFetched: isFetched,
        isFetching: isFetching,
        isFetchingMore: isFetchingMore,
        isStale: isStale,
        query: currentQuery,
        refetch: this.refetch,
        updatedAt: updatedAt
      });
    };

    _proto.updateQuery = function updateQuery() {
      var prevQuery = this.currentQuery; // Remove the initial data when there is an existing query
      // because this data should not be used for a new query

      var config = prevQuery ? _extends({}, this.config, {
        initialData: undefined
      }) : this.config;
      var newQuery = config.queryCache.buildQuery(config.queryKey, config);

      if (newQuery === prevQuery) {
        return false;
      }

      this.previousResult = this.currentResult;
      this.currentQuery = newQuery;
      this.currentResult = this.createResult();

      if (this.started) {
        prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);
        this.currentQuery.subscribeObserver(this);
      }

      return true;
    };

    _proto.onQueryUpdate = function onQueryUpdate(_state, action) {
      var _this$updateListener;

      this.currentResult = this.createResult();
      var _this$currentResult = this.currentResult,
          data = _this$currentResult.data,
          error = _this$currentResult.error,
          isSuccess = _this$currentResult.isSuccess,
          isError = _this$currentResult.isError;

      if (action.type === 'Success' && isSuccess) {
        var _this$config$onSucces, _this$config, _this$config$onSettle, _this$config2;

        (_this$config$onSucces = (_this$config = this.config).onSuccess) == null ? void 0 : _this$config$onSucces.call(_this$config, data);
        (_this$config$onSettle = (_this$config2 = this.config).onSettled) == null ? void 0 : _this$config$onSettle.call(_this$config2, data, null);
        this.updateRefetchInterval();
      } else if (action.type === 'Error' && isError) {
        var _this$config$onError, _this$config3, _this$config$onSettle2, _this$config4;

        (_this$config$onError = (_this$config3 = this.config).onError) == null ? void 0 : _this$config$onError.call(_this$config3, error);
        (_this$config$onSettle2 = (_this$config4 = this.config).onSettled) == null ? void 0 : _this$config$onSettle2.call(_this$config4, undefined, error);
        this.updateRefetchInterval();
      }

      (_this$updateListener = this.updateListener) == null ? void 0 : _this$updateListener.call(this, this.currentResult);
    };

    return QueryObserver;
  }();

  function _empty() {}

  function _awaitIgnored(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty) : Promise.resolve();
    }
  }

  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _continueIgnored(value) {
    if (value && value.then) {
      return value.then(_empty);
    }
  }

  function _await(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  function _invoke(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  function _async(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function _invokeIgnored(body) {
    var result = body();

    if (result && result.then) {
      return result.then(_empty);
    }
  }

  function _settle(pact, state, value) {
    if (!pact.s) {
      if (value instanceof _Pact) {
        if (value.s) {
          if (state & 1) {
            state = value.s;
          }

          value = value.v;
        } else {
          value.o = _settle.bind(null, pact, state);
          return;
        }
      }

      if (value && value.then) {
        value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
        return;
      }

      pact.s = state;
      pact.v = value;
      var observer = pact.o;

      if (observer) {
        observer(pact);
      }
    }
  }

  var _Pact = /*#__PURE__*/function () {
    function _Pact() {}

    _Pact.prototype.then = function (onFulfilled, onRejected) {
      var result = new _Pact();
      var state = this.s;

      if (state) {
        var callback = state & 1 ? onFulfilled : onRejected;

        if (callback) {
          try {
            _settle(result, 1, callback(this.v));
          } catch (e) {
            _settle(result, 2, e);
          }

          return result;
        } else {
          return this;
        }
      }

      this.o = function (_this) {
        try {
          var value = _this.v;

          if (_this.s & 1) {
            _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
          } else if (onRejected) {
            _settle(result, 1, onRejected(value));
          } else {
            _settle(result, 2, value);
          }
        } catch (e) {
          _settle(result, 2, e);
        }
      };

      return result;
    };

    return _Pact;
  }();

  function _isSettledPact(thenable) {
    return thenable instanceof _Pact && thenable.s & 1;
  }

  function _do(body, test) {
    var awaitBody;

    do {
      var result = body();

      if (result && result.then) {
        if (_isSettledPact(result)) {
          result = result.v;
        } else {
          awaitBody = true;
          break;
        }
      }

      var shouldContinue = test();

      if (_isSettledPact(shouldContinue)) {
        shouldContinue = shouldContinue.v;
      }

      if (!shouldContinue) {
        return result;
      }
    } while (!shouldContinue.then);

    var pact = new _Pact();

    var reject = _settle.bind(null, pact, 2);

    (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);
    return pact;

    function _resumeAfterBody(value) {
      result = value;

      for (;;) {
        shouldContinue = test();

        if (_isSettledPact(shouldContinue)) {
          shouldContinue = shouldContinue.v;
        }

        if (!shouldContinue) {
          break;
        }

        if (shouldContinue.then) {
          shouldContinue.then(_resumeAfterTest).then(void 0, reject);
          return;
        }

        result = body();

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_resumeAfterBody).then(void 0, reject);
            return;
          }
        }
      }

      _settle(pact, 1, result);
    }

    function _resumeAfterTest(shouldContinue) {
      if (shouldContinue) {
        do {
          result = body();

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_resumeAfterBody).then(void 0, reject);
              return;
            }
          }

          shouldContinue = test();

          if (_isSettledPact(shouldContinue)) {
            shouldContinue = shouldContinue.v;
          }

          if (!shouldContinue) {
            _settle(pact, 1, result);

            return;
          }
        } while (!shouldContinue.then);

        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _settle(pact, 1, result);
      }
    }
  }

  function _continue(value, then) {
    return value && value.then ? value.then(then) : then(value);
  }

  function _rethrow(thrown, value) {
    if (thrown) throw value;
    return value;
  }

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, result);
  }

  var ActionType;

  (function (ActionType) {
    ActionType["Failed"] = "Failed";
    ActionType["MarkStale"] = "MarkStale";
    ActionType["Fetch"] = "Fetch";
    ActionType["Success"] = "Success";
    ActionType["Error"] = "Error";
    ActionType["SetState"] = "SetState";
  })(ActionType || (ActionType = {}));

  // CLASS
  var Query = /*#__PURE__*/function () {
    function Query(init) {
      this.config = init.config;
      this.queryCache = init.queryCache;
      this.queryKey = init.queryKey;
      this.queryHash = init.queryHash;
      this.notifyGlobalListeners = init.notifyGlobalListeners;
      this.observers = [];
      this.state = getDefaultState(init.config);

      if (init.config.infinite) {
        var infiniteConfig = init.config;
        var infiniteData = this.state.data;

        if (typeof infiniteData !== 'undefined') {
          this.fetchMoreVariable = infiniteConfig.getFetchMore(infiniteData[infiniteData.length - 1], infiniteData);
          this.state.canFetchMore = Boolean(this.fetchMoreVariable);
        } // Here we seed the pageVariables for the query


        if (!this.pageVariables) {
          this.pageVariables = [[].concat(this.queryKey)];
        }
      } // If the query started with data, schedule
      // a stale timeout


      if (!isServer && this.state.data) {
        this.scheduleStaleTimeout(); // Simulate a query healing process

        this.heal(); // Schedule for garbage collection in case
        // nothing subscribes to this query

        this.scheduleGarbageCollection();
      }
    }

    var _proto = Query.prototype;

    _proto.updateConfig = function updateConfig(config) {
      this.config = config;
    };

    _proto.dispatch = function dispatch(action) {
      var _this = this;

      this.state = queryReducer(this.state, action);
      this.observers.forEach(function (d) {
        return d.onQueryUpdate(_this.state, action);
      });
      this.notifyGlobalListeners(this);
    };

    _proto.scheduleStaleTimeout = function scheduleStaleTimeout() {
      var _this2 = this;

      if (isServer) {
        return;
      }

      this.clearStaleTimeout();

      if (this.state.isStale || this.config.staleTime === Infinity) {
        return;
      }

      this.staleTimeout = setTimeout(function () {
        _this2.invalidate();
      }, this.config.staleTime);
    };

    _proto.invalidate = function invalidate() {
      this.clearStaleTimeout();

      if (this.state.isStale) {
        return;
      }

      this.dispatch({
        type: ActionType.MarkStale
      });
    };

    _proto.scheduleGarbageCollection = function scheduleGarbageCollection() {
      var _this3 = this;

      if (isServer) {
        return;
      }

      this.clearCacheTimeout();

      if (this.config.cacheTime === Infinity) {
        return;
      }

      this.cacheTimeout = setTimeout(function () {
        _this3.clear();
      }, typeof this.state.data === 'undefined' && this.state.status !== exports.QueryStatus.Error ? 0 : this.config.cacheTime);
    };

    _proto.refetch = function refetch() {
      try {
        var _this5 = this;

        return _continueIgnored(_catch(function () {
          return _awaitIgnored(_this5.fetch());
        }, function (error) {
          Console.error(error);
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.heal = function heal() {
      // Stop the query from being garbage collected
      this.clearCacheTimeout(); // Mark the query as not cancelled

      this.cancelled = null;
    };

    _proto.cancel = function cancel() {
      this.cancelled = cancelledError;

      if (this.cancelPromises) {
        this.cancelPromises();
      }

      delete this.promise;
    };

    _proto.clearTimersObservers = function clearTimersObservers() {
      this.observers.forEach(function (observer) {
        observer.clearRefetchInterval();
      });
    };

    _proto.clearStaleTimeout = function clearStaleTimeout() {
      if (this.staleTimeout) {
        clearTimeout(this.staleTimeout);
        this.staleTimeout = undefined;
      }
    };

    _proto.clearCacheTimeout = function clearCacheTimeout() {
      if (this.cacheTimeout) {
        clearTimeout(this.cacheTimeout);
        this.cacheTimeout = undefined;
      }
    };

    _proto.clearRetryTimeout = function clearRetryTimeout() {
      if (this.retryTimeout) {
        clearTimeout(this.retryTimeout);
        this.retryTimeout = undefined;
      }
    };

    _proto.setState = function setState(updater) {
      this.dispatch({
        type: ActionType.SetState,
        updater: updater
      });
    };

    _proto.setData = function setData(updater) {
      var _this$config$isDataEq, _this$config;

      var prevData = this.state.data; // Get the new data

      var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data

      data = replaceEqualDeep(prevData, data); // Use prev data if an isDataEqual function is defined and returns `true`

      if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {
        data = prevData;
      }

      var isStale = this.config.staleTime === 0; // Set data and mark it as cached

      this.dispatch({
        type: ActionType.Success,
        data: data,
        isStale: isStale
      });

      if (!isStale) {
        // Schedule a fresh invalidation!
        this.scheduleStaleTimeout();
      }
    };

    _proto.clear = function clear() {
      this.clearStaleTimeout();
      this.clearCacheTimeout();
      this.clearRetryTimeout();
      this.clearTimersObservers();
      this.cancel();
      delete this.queryCache.queries[this.queryHash];
      this.notifyGlobalListeners(this);
    };

    _proto.isEnabled = function isEnabled() {
      return this.observers.some(function (observer) {
        return observer.config.enabled;
      });
    };

    _proto.shouldRefetchOnWindowFocus = function shouldRefetchOnWindowFocus() {
      return this.isEnabled() && this.state.isStale && this.observers.some(function (observer) {
        return observer.config.refetchOnWindowFocus;
      });
    };

    _proto.subscribe = function subscribe(listener) {
      var observer = new QueryObserver(_extends({
        queryCache: this.queryCache,
        queryKey: this.queryKey
      }, this.config));
      observer.subscribe(listener);
      return observer;
    };

    _proto.subscribeObserver = function subscribeObserver(observer) {
      this.observers.push(observer);
      this.heal();
    };

    _proto.unsubscribeObserver = function unsubscribeObserver(observer, preventGC) {
      this.observers = this.observers.filter(function (x) {
        return x !== observer;
      });

      if (!this.observers.length) {
        this.cancel();

        if (!preventGC) {
          // Schedule garbage collection
          this.scheduleGarbageCollection();
        }
      }
    } // Set up the core fetcher function
    ;

    _proto.tryFetchData = function tryFetchData(fn, args) {
      try {
        var _this7 = this;

        return _catch(function () {
          // Perform the query
          var filter = _this7.config.queryFnParamsFilter;
          var params = filter ? filter(args) : args; // Perform the query

          var promiseOrValue = fn.apply(void 0, params);

          _this7.cancelPromises = function () {
            var _ref;

            return (_ref = promiseOrValue) == null ? void 0 : _ref.cancel == null ? void 0 : _ref.cancel();
          };

          return _await(promiseOrValue, function (data) {
            delete _this7.shouldContinueRetryOnFocus;
            delete _this7.cancelPromises;
            if (_this7.cancelled) throw _this7.cancelled;
            return data;
          });
        }, function (error) {
          var _exit = false;
          delete _this7.cancelPromises;
          if (_this7.cancelled) throw _this7.cancelled; // Do we need to retry the request?

          return _invoke(function () {
            if (_this7.config.retry === true || _this7.state.failureCount < _this7.config.retry || typeof _this7.config.retry === 'function' && _this7.config.retry(_this7.state.failureCount, error)) {
              // If we retry, increase the failureCount
              _this7.dispatch({
                type: ActionType.Failed
              }); // Only retry if the document is visible


              if (!isDocumentVisible()) {
                // set this flag to continue retries on focus
                _this7.shouldContinueRetryOnFocus = true; // Resolve a

                _exit = true;
                return new Promise(noop);
              }

              delete _this7.shouldContinueRetryOnFocus; // Determine the retryDelay

              var delay = functionalUpdate(_this7.config.retryDelay, _this7.state.failureCount); // Return a new promise with the retry

              _exit = true;
              return _await(new Promise(function (resolve, reject) {
                // Keep track of the retry timeout
                _this7.retryTimeout = setTimeout(_async(function () {
                  return _this7.cancelled ? reject(_this7.cancelled) : _catch(function () {
                    return _await(_this7.tryFetchData(fn, args), function (data) {
                      if (_this7.cancelled) return reject(_this7.cancelled);
                      resolve(data);
                    });
                  }, function (error) {
                    if (_this7.cancelled) return reject(_this7.cancelled);
                    reject(error);
                  });
                }), delay);
              }));
            }
          }, function (_result) {
            if (_exit) return _result;
            throw error;
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetch = function fetch(options) {
      try {
        var _this9 = this;

        var queryFn = _this9.config.queryFn;

        if (!queryFn) {
          return;
        } // If we are already fetching, return current promise


        if (_this9.promise) {
          return _this9.promise;
        }

        if (_this9.config.infinite) {
          var infiniteConfig = _this9.config;
          var infiniteData = _this9.state.data;
          var fetchMore = options == null ? void 0 : options.fetchMore;
          var originalQueryFn = queryFn;
          queryFn = _async(function () {
            var _interrupt = false;
            var data = [];
            var pageVariables = _this9.pageVariables ? [].concat(_this9.pageVariables) : [];
            var rebuiltPageVariables = [];
            return _continue(_do(function () {
              var args = pageVariables.shift();
              return _invokeIgnored(function () {
                if (!data.length) {
                  var _push3 = data.push;
                  // the first page query doesn't need to be rebuilt
                  return _await(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {
                    _push3.call(data, _originalQueryFn);

                    rebuiltPageVariables.push(args);
                  });
                } else {
                  // get an up-to-date cursor based on the previous data set
                  var nextCursor = infiniteConfig.getFetchMore(data[data.length - 1], data); // break early if there's no next cursor
                  // otherwise we'll start from the beginning
                  // which will cause unwanted duplication

                  if (!nextCursor) {
                    _interrupt = true;
                    return;
                  }

                  var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);
                  var _push4 = data.push;
                  return _await(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {
                    _push4.call(data, _originalQueryFn2);

                    rebuiltPageVariables.push(pageArgs);
                  });
                }
              });
            }, function () {
              return !_interrupt && !!pageVariables.length;
            }), function () {
              _this9.fetchMoreVariable = infiniteConfig.getFetchMore(data[data.length - 1], data);
              _this9.state.canFetchMore = Boolean(_this9.fetchMoreVariable);
              _this9.pageVariables = rebuiltPageVariables;
              return data;
            });
          });

          if (fetchMore) {
            queryFn = _async(function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return _finallyRethrows(function () {
                var fetchMoreVariable = fetchMore.fetchMoreVariable,
                    previous = fetchMore.previous;

                _this9.setState(function (old) {
                  return _extends({}, old, {
                    isFetchingMore: previous ? 'previous' : 'next'
                  });
                });

                var newArgs = [].concat(args, [fetchMoreVariable]);

                if (_this9.pageVariables) {
                  _this9.pageVariables[previous ? 'unshift' : 'push'](newArgs);
                } else {
                  _this9.pageVariables = [newArgs];
                }

                return _await(originalQueryFn.apply(void 0, newArgs), function (newData) {
                  var data;

                  if (!infiniteData) {
                    data = [newData];
                  } else if (previous) {
                    data = [newData].concat(infiniteData);
                  } else {
                    data = [].concat(infiniteData, [newData]);
                  }

                  _this9.fetchMoreVariable = infiniteConfig.getFetchMore(newData, data);
                  _this9.state.canFetchMore = Boolean(_this9.fetchMoreVariable);
                  return data;
                });
              }, function (_wasThrown, _result3) {
                _this9.setState(function (old) {
                  return _extends({}, old, {
                    isFetchingMore: false
                  });
                });

                return _rethrow(_wasThrown, _result3);
              });
            });
          }
        }

        _this9.promise = _async(function () {
          // If there are any retries pending for this query, kill them
          _this9.cancelled = null;
          return _catch(function () {
            // Set to fetching state if not already in it
            if (!_this9.state.isFetching) {
              _this9.dispatch({
                type: ActionType.Fetch
              });
            } // Try to get the data


            return _await(_this9.tryFetchData(queryFn, _this9.queryKey), function (data) {
              _this9.setData(data);

              delete _this9.promise;
              return data;
            });
          }, function (error) {
            _this9.dispatch({
              type: ActionType.Error,
              cancelled: error === _this9.cancelled,
              error: error
            });

            delete _this9.promise;

            if (error !== _this9.cancelled) {
              throw error;
            }
          });
        })();
        return _this9.promise;
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {
      return this.fetch({
        fetchMore: {
          fetchMoreVariable: fetchMoreVariable != null ? fetchMoreVariable : this.fetchMoreVariable,
          previous: (options == null ? void 0 : options.previous) || false
        }
      });
    };

    return Query;
  }();

  function getDefaultState(config) {
    var _config$initialStale;

    var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;
    var hasInitialData = typeof initialData !== 'undefined';
    var isStale = !config.enabled || (typeof config.initialStale === 'function' ? config.initialStale() : (_config$initialStale = config.initialStale) != null ? _config$initialStale : !hasInitialData);
    var initialStatus = hasInitialData ? exports.QueryStatus.Success : config.enabled ? exports.QueryStatus.Loading : exports.QueryStatus.Idle;
    return _extends({}, getStatusProps(initialStatus), {
      error: null,
      isFetched: false,
      isFetching: initialStatus === exports.QueryStatus.Loading,
      isFetchingMore: false,
      failureCount: 0,
      isStale: isStale,
      data: initialData,
      updatedAt: hasInitialData ? Date.now() : 0
    });
  }

  function queryReducer(state, action) {
    switch (action.type) {
      case ActionType.Failed:
        return _extends({}, state, {
          failureCount: state.failureCount + 1
        });

      case ActionType.MarkStale:
        return _extends({}, state, {
          isStale: true
        });

      case ActionType.Fetch:
        var status = typeof state.data !== 'undefined' ? exports.QueryStatus.Success : exports.QueryStatus.Loading;
        return _extends({}, state, getStatusProps(status), {
          isFetching: true,
          failureCount: 0
        });

      case ActionType.Success:
        return _extends({}, state, getStatusProps(exports.QueryStatus.Success), {
          data: action.data,
          error: null,
          isStale: action.isStale,
          isFetched: true,
          isFetching: false,
          updatedAt: Date.now(),
          failureCount: 0
        });

      case ActionType.Error:
        return _extends({}, state, {
          failureCount: state.failureCount + 1,
          isFetched: true,
          isFetching: false,
          isStale: true
        }, !action.cancelled && _extends({}, getStatusProps(exports.QueryStatus.Error), {
          error: action.error,
          throwInErrorBoundary: true
        }));

      case ActionType.SetState:
        return functionalUpdate(action.updater, state);

      default:
        return state;
    }
  }

  // CLASS
  function _empty$1() {}

  function _awaitIgnored$1(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty$1) : Promise.resolve();
    }
  }

  function _catch$1(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _invoke$1(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  var QueryCache = /*#__PURE__*/function () {
    function QueryCache(config) {
      this.config = config || {}; // A frozen cache does not add new queries to the cache

      this.globalListeners = [];
      this.queries = {};
      this.isFetching = 0;
    }

    var _proto = QueryCache.prototype;

    _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {
      var _this = this;

      this.isFetching = Object.values(this.queries).reduce(function (acc, query) {
        return query.state.isFetching ? acc + 1 : acc;
      }, 0);
      this.globalListeners.forEach(function (d) {
        return d(_this, query);
      });
    };

    _proto.getDefaultConfig = function getDefaultConfig() {
      return this.config.defaultConfig;
    };

    _proto.getDefaultedQueryConfig = function getDefaultedQueryConfig$1(config) {
      return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {
        queryCache: this
      });
    };

    _proto.subscribe = function subscribe(listener) {
      var _this2 = this;

      this.globalListeners.push(listener);
      return function () {
        _this2.globalListeners.splice(_this2.globalListeners.indexOf(listener), 1);
      };
    };

    _proto.clear = function clear(options) {
      Object.values(this.queries).forEach(function (query) {
        return query.clear();
      });
      this.queries = {};

      if (options == null ? void 0 : options.notify) {
        this.notifyGlobalListeners();
      }
    };

    _proto.getQueries = function getQueries(predicate, options) {
      if (predicate === true) {
        return Object.values(this.queries);
      }

      var predicateFn;

      if (typeof predicate === 'function') {
        predicateFn = predicate;
      } else {
        var _config = this.getDefaultedQueryConfig();

        var _ref = _config.queryKeySerializerFn(predicate),
            queryHash = _ref[0],
            _queryKey = _ref[1];

        predicateFn = function predicateFn(d) {
          return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);
        };
      }

      return Object.values(this.queries).filter(predicateFn);
    };

    _proto.getQuery = function getQuery(predicate) {
      return this.getQueries(predicate, {
        exact: true
      })[0];
    };

    _proto.getQueryData = function getQueryData(predicate) {
      var _this$getQuery;

      return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;
    };

    _proto.removeQueries = function removeQueries(predicate, options) {
      this.getQueries(predicate, options).forEach(function (query) {
        return query.clear();
      });
    };

    _proto.cancelQueries = function cancelQueries(predicate, options) {
      this.getQueries(predicate, options).forEach(function (query) {
        return query.cancel();
      });
    };

    _proto.invalidateQueries = function invalidateQueries(predicate, options) {
      try {
        var _this4 = this;

        var _ref2 = options || {},
            _ref2$refetchActive = _ref2.refetchActive,
            refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,
            _ref2$refetchInactive = _ref2.refetchInactive,
            refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,
            throwOnError = _ref2.throwOnError;

        return _catch$1(function () {
          return _awaitIgnored$1(Promise.all(_this4.getQueries(predicate, options).map(function (query) {
            if (query.observers.length) {
              if (refetchActive && query.isEnabled()) {
                return query.fetch();
              }
            } else {
              if (refetchInactive) {
                return query.fetch();
              }
            }

            return query.invalidate();
          })));
        }, function (err) {
          if (throwOnError) {
            throw err;
          }
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.resetErrorBoundaries = function resetErrorBoundaries() {
      this.getQueries(true).forEach(function (query) {
        query.state.throwInErrorBoundary = false;
      });
    };

    _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {
      var _this5 = this;

      var config = this.getDefaultedQueryConfig(queryConfig);

      var _ref3 = config.queryKeySerializerFn(userQueryKey),
          queryHash = _ref3[0],
          queryKey = _ref3[1];

      var query;

      if (this.queries[queryHash]) {
        query = this.queries[queryHash];
        query.updateConfig(config);
      }

      if (!query) {
        query = new Query({
          queryCache: this,
          queryKey: queryKey,
          queryHash: queryHash,
          config: config,
          notifyGlobalListeners: function notifyGlobalListeners(query) {
            _this5.notifyGlobalListeners(query);
          }
        });

        if (!this.config.frozen) {
          this.queries[queryHash] = query;

          if (isServer) {
            this.notifyGlobalListeners();
          } else {
            // Here, we setTimeout so as to not trigger
            // any setState's in parent components in the
            // middle of the render phase.
            setTimeout(function () {
              _this5.notifyGlobalListeners();
            });
          }
        }
      }

      return query;
    } // Parameter syntax with optional prefetch options
    ;

    // Implementation
    _proto.prefetchQuery = function prefetchQuery() {
      try {
        var _this7 = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {
          args[3] = args[1];
          args[1] = undefined;
          args[2] = undefined;
        }

        var _getQueryArgs = getQueryArgs(args),
            _queryKey2 = _getQueryArgs[0],
            _config2 = _getQueryArgs[1],
            _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652


        var configWithoutRetry = _extends({
          retry: false
        }, _config2);

        return _catch$1(function () {
          var query = _this7.buildQuery(_queryKey2, configWithoutRetry);

          return _invoke$1(function () {
            if ((_options == null ? void 0 : _options.force) || query.state.isStale) {
              return _awaitIgnored$1(query.fetch());
            }
          }, function () {
            return query.state.data;
          });
        }, function (err) {
          if (_options == null ? void 0 : _options.throwOnError) {
            throw err;
          }

          Console.error(err);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.setQueryData = function setQueryData(queryKey, updater, config) {
      var query = this.getQuery(queryKey);

      if (!query) {
        query = this.buildQuery(queryKey, config);
      }

      query.setData(updater);
    };

    return QueryCache;
  }();
  var defaultQueryCache = makeQueryCache({
    frozen: isServer
  });
  var queryCaches = [defaultQueryCache];
  function makeQueryCache(config) {
    return new QueryCache(config);
  }

  var visibilityChangeEvent = 'visibilitychange';
  var focusEvent = 'focus';

  var onWindowFocus = function onWindowFocus() {
    if (isDocumentVisible() && isOnline()) {
      queryCaches.forEach(function (queryCache) {
        return queryCache.invalidateQueries(function (query) {
          if (!query.shouldRefetchOnWindowFocus()) {
            return false;
          }

          if (query.shouldContinueRetryOnFocus) {
            // delete promise, so refetching will create new one
            delete query.promise;
          }

          return true;
        }).catch(Console.error);
      });
    }
  };

  var removePreviousHandler;
  function setFocusHandler(callback) {
    // Unsub the old watcher
    if (removePreviousHandler) {
      removePreviousHandler();
    } // Sub the new watcher


    removePreviousHandler = callback(onWindowFocus);
  }
  setFocusHandler(function (handleFocus) {
    var _window;

    // Listen to visibillitychange and focus
    if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
      window.addEventListener(visibilityChangeEvent, handleFocus, false);
      window.addEventListener(focusEvent, handleFocus, false);
      return function () {
        // Be sure to unsubscribe if a new handler is set
        window.removeEventListener(visibilityChangeEvent, handleFocus);
        window.removeEventListener(focusEvent, handleFocus);
      };
    }

    return;
  });

  var queryCacheContext = React.createContext(defaultQueryCache);
  var useQueryCache = function useQueryCache() {
    return React.useContext(queryCacheContext);
  };
  var ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {
    var queryCache = _ref.queryCache,
        children = _ref.children;
    var resolvedQueryCache = React.useMemo(function () {
      return queryCache || makeQueryCache();
    }, [queryCache]);
    React.useEffect(function () {
      queryCaches.push(resolvedQueryCache);
      return function () {
        // remove the cache from the active list
        var i = queryCaches.indexOf(resolvedQueryCache);

        if (i > -1) {
          queryCaches.splice(i, 1);
        } // if the resolvedQueryCache was created by us, we need to tear it down


        if (queryCache == null) {
          resolvedQueryCache.clear({
            notify: false
          });
        }
      };
    }, [resolvedQueryCache, queryCache]);
    return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {
      value: resolvedQueryCache
    }, children);
  };

  var configContext = React.createContext(undefined);
  function useContextConfig() {
    return React.useContext(configContext);
  }
  var ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {
    var config = _ref.config,
        children = _ref.children;
    var parentConfig = useContextConfig();
    var mergedConfig = React.useMemo(function () {
      return parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config;
    }, [config, parentConfig]);
    return /*#__PURE__*/React.createElement(configContext.Provider, {
      value: mergedConfig
    }, children);
  };

  function useGetLatest(obj) {
    var ref = React.useRef(obj);
    ref.current = obj;
    return React.useCallback(function () {
      return ref.current;
    }, []);
  }
  function useMountedCallback(callback) {
    var mounted = React.useRef(false);
    React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {
      mounted.current = true;
      return function () {
        mounted.current = false;
      };
    }, []);
    return React.useCallback(function () {
      return mounted.current ? callback.apply(void 0, arguments) : void 0;
    }, [callback]);
  }
  function useRerenderer() {
    var rerender = useMountedCallback(React.useState()[1]);
    return React.useCallback(function () {
      return rerender({});
    }, [rerender]);
  }

  function useIsFetching() {
    var queryCache = useQueryCache();
    var rerender = useRerenderer();
    var isFetching = queryCache.isFetching;
    var getIsFetching = useGetLatest(isFetching);
    React.useEffect(function () {
      return queryCache.subscribe(function (newCache) {
        if (getIsFetching() !== newCache.isFetching) {
          rerender();
        }
      });
    }, [getIsFetching, queryCache, rerender]);
    return isFetching;
  }

  function useDefaultedMutationConfig(config) {
    var contextConfig = useContextConfig();
    var contextQueryCache = useQueryCache();
    var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;
    var queryCacheConfig = queryCache.getDefaultConfig();
    return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {
      queryCache: queryCache
    });
  }

  function _await$1(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  var ActionType$1;

  function _catch$2(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _async$1(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  (function (ActionType) {
    ActionType["Reset"] = "Reset";
    ActionType["Loading"] = "Loading";
    ActionType["Resolve"] = "Resolve";
    ActionType["Reject"] = "Reject";
  })(ActionType$1 || (ActionType$1 = {}));

  // HOOK
  var getDefaultState$1 = function getDefaultState() {
    return _extends({}, getStatusProps(exports.QueryStatus.Idle), {
      data: undefined,
      error: null
    });
  };

  function mutationReducer(state, action) {
    switch (action.type) {
      case ActionType$1.Reset:
        return getDefaultState$1();

      case ActionType$1.Loading:
        return _extends({}, getStatusProps(exports.QueryStatus.Loading), {
          data: undefined,
          error: null
        });

      case ActionType$1.Resolve:
        return _extends({}, getStatusProps(exports.QueryStatus.Success), {
          data: action.data,
          error: null
        });

      case ActionType$1.Reject:
        return _extends({}, getStatusProps(exports.QueryStatus.Error), {
          data: undefined,
          error: action.error
        });

      default:
        return state;
    }
  }

  function useMutation(mutationFn, config) {
    if (config === void 0) {
      config = {};
    }

    config = useDefaultedMutationConfig(config);
    var getConfig = useGetLatest(config);

    var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState$1),
        state = _React$useReducer[0],
        unsafeDispatch = _React$useReducer[1];

    var dispatch = useMountedCallback(unsafeDispatch);
    var getMutationFn = useGetLatest(mutationFn);
    var latestMutationRef = React.useRef();
    var mutate = React.useCallback(_async$1(function (variables, mutateConfig) {
      if (mutateConfig === void 0) {
        mutateConfig = {};
      }

      var config = getConfig();
      var mutationId = uid();
      latestMutationRef.current = mutationId;

      var isLatest = function isLatest() {
        return latestMutationRef.current === mutationId;
      };

      var snapshotValue;
      return _catch$2(function () {
        dispatch({
          type: ActionType$1.Loading
        });
        return _await$1(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {
          snapshotValue = _config$onMutate;
          return _await$1(getMutationFn()(variables), function (data) {
            if (isLatest()) {
              dispatch({
                type: ActionType$1.Resolve,
                data: data
              });
            }

            return _await$1(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {
              return _await$1(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {
                return _await$1(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {
                  return _await$1(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {
                    return data;
                  });
                });
              });
            });
          });
        });
      }, function (error) {
        Console.error(error);
        return _await$1(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {
          return _await$1(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {
            return _await$1(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {
              return _await$1(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {
                var _mutateConfig$throwOn;

                if (isLatest()) {
                  dispatch({
                    type: ActionType$1.Reject,
                    error: error
                  });
                }

                if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {
                  throw error;
                }
              });
            });
          });
        });
      });
    }), [dispatch, getConfig, getMutationFn]);
    var reset = React.useCallback(function () {
      dispatch({
        type: ActionType$1.Reset
      });
    }, [dispatch]);
    React.useEffect(function () {
      var _getConfig = getConfig(),
          suspense = _getConfig.suspense,
          useErrorBoundary = _getConfig.useErrorBoundary;

      if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {
        throw state.error;
      }
    }, [getConfig, state.error]);
    return [mutate, _extends({}, state, {
      reset: reset
    })];
  }

  function useDefaultedQueryConfig(config) {
    var contextConfig = useContextConfig();
    var contextQueryCache = useQueryCache();
    var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;
    var queryCacheConfig = queryCache.getDefaultConfig();
    return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {
      queryCache: queryCache
    });
  }

  function useBaseQuery(config) {
    if (config === void 0) {
      config = {};
    }

    config = useDefaultedQueryConfig(config); // Make a rerender function

    var rerender = useRerenderer(); // Create query observer

    var observerRef = React.useRef();
    var firstRender = !observerRef.current;
    var observer = observerRef.current || new QueryObserver(config);
    observerRef.current = observer; // Subscribe to the observer

    React.useEffect(function () {
      return observer.subscribe(function () {
        Promise.resolve().then(rerender);
      });
    }, [observer, rerender]); // Update config

    if (!firstRender) {
      observer.updateConfig(config);
    }

    var result = observer.getCurrentResult(); // Handle suspense

    if (config.suspense || config.useErrorBoundary) {
      if (result.isError && result.query.state.throwInErrorBoundary) {
        throw result.error;
      }

      if (config.enabled && config.suspense && !result.isSuccess) {
        observer.subscribe();
        throw observer.fetch().finally(function () {
          observer.unsubscribe(true);
        });
      }
    }

    return result;
  }

  // Implementation
  function useQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var config = getQueryArgs(args)[1];
    return useBaseQuery(config);
  }

  // as the query key changes, we keep the results from the
  // last query and use them as placeholder data in the next one
  // We DON'T use it as initial data though. That's important
  // TYPES

  // Implementation
  function usePaginatedQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var config = getQueryArgs(args)[1];
    var result = useBaseQuery(_extends({}, config, {
      keepPreviousData: true
    }));
    return _extends({}, result, {
      resolvedData: result.data,
      latestData: result.query.state.data === result.data ? result.data : undefined
    });
  }

  // Implementation
  function useInfiniteQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var config = getQueryArgs(args)[1];
    return useBaseQuery(_extends({}, config, {
      infinite: true
    }));
  }

  exports.ReactQueryCacheProvider = ReactQueryCacheProvider;
  exports.ReactQueryConfigProvider = ReactQueryConfigProvider;
  exports.deepIncludes = deepIncludes;
  exports.makeQueryCache = makeQueryCache;
  exports.queryCache = defaultQueryCache;
  exports.queryCaches = queryCaches;
  exports.setConsole = setConsole;
  exports.setFocusHandler = setFocusHandler;
  exports.stableStringify = stableStringify;
  exports.useInfiniteQuery = useInfiniteQuery;
  exports.useIsFetching = useIsFetching;
  exports.useMutation = useMutation;
  exports.usePaginatedQuery = usePaginatedQuery;
  exports.useQuery = useQuery;
  exports.useQueryCache = useQueryCache;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-query.development.js.map
