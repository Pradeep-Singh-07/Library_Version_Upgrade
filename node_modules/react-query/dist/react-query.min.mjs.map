{"version":3,"file":"react-query.min.mjs","sources":["../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/queryObserver.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/useMutation.ts","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useDefaultedMutationConfig.tsx","../src/react/useBaseQuery.ts","../src/react/useDefaultedQueryConfig.tsx","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts"],"sourcesContent":["import type { Query, FetchMoreOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type QueryKeyObject =\n  | object\n  | { [key: string]: QueryKey }\n  | { [key: number]: QueryKey }\n\nexport type QueryKeyPrimitive = string | boolean | number | null | undefined\n\nexport type QueryKeyWithoutObjectAndArray = QueryKeyPrimitive\n\nexport type QueryKeyWithoutObject =\n  | QueryKeyWithoutObjectAndArray\n  | readonly QueryKey[]\n\nexport type QueryKeyWithoutArray =\n  | QueryKeyWithoutObjectAndArray\n  | QueryKeyObject\n\nexport type QueryKey = QueryKeyWithoutObject | QueryKeyObject\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\n// The tuple variants are only to infer types in the public API\nexport type TupleQueryKey = readonly [QueryKey, ...QueryKey[]]\n\nexport type TupleQueryFunction<TResult, TKey extends TupleQueryKey> = (\n  ...args: TKey\n) => TResult | Promise<TResult>\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   */\n  enabled?: boolean | unknown\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  staleTime?: number\n  cacheTime?: number\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  queryFn?: QueryFunction<TResult>\n  queryKey?: QueryKey\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  initialData?: TResult | InitialDataFunction<TResult>\n  initialStale?: boolean | InitialStaleFunction\n  infinite?: true\n}\n\nexport interface QueryObserverConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult, TError> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Defaults to `true`.\n   */\n  enabled?: boolean | unknown\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * Defaults to `false`.\n   */\n  refetchInterval?: number\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * Set this to `true` or `false` to enable/disable automatic refetching on window focus for this query.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?: boolean\n  /**\n   * If set to `false`, will disable additional instances of a query to trigger background refetches.\n   * Defaults to `true`.\n   */\n  refetchOnMount?: boolean\n  /**\n   * This callback will fire any time the query successfully fetches new data.\n   */\n  onSuccess?: (data: TResult) => void\n  /**\n   * This callback will fire if the query encounters an error and will be passed the error.\n   */\n  onError?: (err: TError) => void\n  /**\n   * This callback will fire any time the query is either successfully fetched or errors and be passed either the data or error.\n   */\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * Defaults to `false`.\n   */\n  useErrorBoundary?: boolean\n  /**\n   * If set to `true`, the query will suspend when `status === 'loading'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * Set this to `true` to keep the previous `data` when fetching based on a new query key.\n   * Defaults to `false`.\n   */\n  keepPreviousData?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult[], TError> {\n  getFetchMore: (lastPage: TResult, allPages: TResult[]) => unknown\n}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  canFetchMore: boolean | undefined\n  clear: () => void\n  data: TResult | undefined\n  error: TError | null\n  failureCount: number\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult | undefined>\n  isError: boolean\n  isFetched: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isStale: boolean\n  isSuccess: boolean\n  query: Query<TResult, TError>\n  refetch: () => Promise<void>\n  status: QueryStatus\n  updatedAt: number\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<void> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<void> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<void> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\n// UTILS\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport const globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport function noop(): void {\n  return void 0\n}\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value')\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible(): boolean {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true\n  }\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey\n    queryFn = args[0].queryFn\n    config = args[0].config\n    options = args[1]\n  } else if (isObject(args[1])) {\n    queryKey = args[0]\n    config = args[1]\n    options = args[2]\n  } else {\n    queryKey = args[0]\n    queryFn = args[1]\n    config = args[2]\n    options = args[3]\n  }\n\n  config = config ? { queryKey, ...config } : { queryKey }\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  return replaceEqualDeep(a, b) === a\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\nexport function isObject(a: unknown): boolean {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n","import { stableStringify } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  QueryConfig,\n  MutationConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchOnMount: true,\n  },\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getDefaultedQueryConfig<TResult, TError>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>,\n  configOverrides?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n    ...configOverrides,\n  } as QueryConfig<TResult, TError>\n}\n\nexport function getDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>,\n  configOverrides?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n    ...configOverrides,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import { getStatusProps, isServer, isDocumentVisible, Console } from './utils'\nimport type { QueryResult, QueryObserverConfig } from './types'\nimport type { Query, QueryState, Action, FetchMoreOptions } from './query'\n\nexport type UpdateListener<TResult, TError> = (\n  result: QueryResult<TResult, TError>\n) => void\n\nexport class QueryObserver<TResult, TError> {\n  config: QueryObserverConfig<TResult, TError>\n\n  private currentQuery!: Query<TResult, TError>\n  private currentResult!: QueryResult<TResult, TError>\n  private previousResult?: QueryResult<TResult, TError>\n  private updateListener?: UpdateListener<TResult, TError>\n  private refetchIntervalId?: number\n  private started?: boolean\n\n  constructor(config: QueryObserverConfig<TResult, TError>) {\n    this.config = config\n\n    // Bind exposed methods\n    this.clear = this.clear.bind(this)\n    this.refetch = this.refetch.bind(this)\n    this.fetchMore = this.fetchMore.bind(this)\n\n    // Subscribe to the query\n    this.updateQuery()\n  }\n\n  subscribe(listener?: UpdateListener<TResult, TError>): () => void {\n    this.started = true\n    this.updateListener = listener\n    this.currentQuery.subscribeObserver(this)\n    this.optionalFetch()\n    this.updateRefetchInterval()\n    return this.unsubscribe.bind(this)\n  }\n\n  unsubscribe(preventGC?: boolean): void {\n    this.started = false\n    this.updateListener = undefined\n    this.clearRefetchInterval()\n    this.currentQuery.unsubscribeObserver(this, preventGC)\n  }\n\n  updateConfig(config: QueryObserverConfig<TResult, TError>): void {\n    const prevConfig = this.config\n    this.config = config\n\n    const updated = this.updateQuery()\n\n    // Take no further actions if the observer did not start yet\n    if (!this.started) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (updated) {\n      this.optionalFetch()\n      this.updateRefetchInterval()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch()\n    }\n\n    // Update refetch interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.refetchInterval !== prevConfig.refetchInterval ||\n      config.refetchIntervalInBackground !==\n        prevConfig.refetchIntervalInBackground\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  getCurrentResult(): QueryResult<TResult, TError> {\n    return this.currentResult\n  }\n\n  clear(): void {\n    return this.currentQuery.clear()\n  }\n\n  async refetch(): Promise<void> {\n    this.currentQuery.updateConfig(this.config)\n    return this.currentQuery.refetch()\n  }\n\n  async fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    this.currentQuery.updateConfig(this.config)\n    return this.currentQuery.fetchMore(fetchMoreVariable, options)\n  }\n\n  async fetch(): Promise<TResult | undefined> {\n    this.currentQuery.updateConfig(this.config)\n    return this.currentQuery.fetch().catch(error => {\n      Console.error(error)\n      return undefined\n    })\n  }\n\n  private optionalFetch(): void {\n    if (\n      this.config.enabled && // Don't auto refetch if disabled\n      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n      this.currentResult.isStale && // Only refetch if stale\n      (this.config.refetchOnMount || this.currentQuery.observers.length === 1)\n    ) {\n      this.fetch()\n    }\n  }\n\n  private updateRefetchInterval(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearRefetchInterval()\n\n    if (\n      !this.config.enabled ||\n      !this.config.refetchInterval ||\n      this.config.refetchInterval < 0 ||\n      this.config.refetchInterval === Infinity\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.config.refetchIntervalInBackground || isDocumentVisible()) {\n        this.fetch()\n      }\n    }, this.config.refetchInterval)\n  }\n\n  clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  private createResult(): QueryResult<TResult, TError> {\n    const { currentQuery, previousResult, config } = this\n\n    const {\n      canFetchMore,\n      error,\n      failureCount,\n      isFetched,\n      isFetching,\n      isFetchingMore,\n      isLoading,\n      isStale,\n    } = currentQuery.state\n\n    let { data, status, updatedAt } = currentQuery.state\n\n    // Keep previous data if needed\n    if (config.keepPreviousData && isLoading && previousResult?.isSuccess) {\n      data = previousResult.data\n      updatedAt = previousResult.updatedAt\n      status = previousResult.status\n    }\n\n    return {\n      ...getStatusProps(status),\n      canFetchMore,\n      clear: this.clear,\n      data,\n      error,\n      failureCount,\n      fetchMore: this.fetchMore,\n      isFetched,\n      isFetching,\n      isFetchingMore,\n      isStale,\n      query: currentQuery,\n      refetch: this.refetch,\n      updatedAt,\n    }\n  }\n\n  private updateQuery(): boolean {\n    const prevQuery = this.currentQuery\n\n    // Remove the initial data when there is an existing query\n    // because this data should not be used for a new query\n    const config = prevQuery\n      ? { ...this.config, initialData: undefined }\n      : this.config\n\n    const newQuery = config.queryCache!.buildQuery(config.queryKey, config)\n\n    if (newQuery === prevQuery) {\n      return false\n    }\n\n    this.previousResult = this.currentResult\n    this.currentQuery = newQuery\n    this.currentResult = this.createResult()\n\n    if (this.started) {\n      prevQuery?.unsubscribeObserver(this)\n      this.currentQuery.subscribeObserver(this)\n    }\n\n    return true\n  }\n\n  onQueryUpdate(\n    _state: QueryState<TResult, TError>,\n    action: Action<TResult, TError>\n  ): void {\n    this.currentResult = this.createResult()\n\n    const { data, error, isSuccess, isError } = this.currentResult\n\n    if (action.type === 'Success' && isSuccess) {\n      this.config.onSuccess?.(data!)\n      this.config.onSettled?.(data!, null)\n      this.updateRefetchInterval()\n    } else if (action.type === 'Error' && isError) {\n      this.config.onError?.(error!)\n      this.config.onSettled?.(undefined, error!)\n      this.updateRefetchInterval()\n    }\n\n    this.updateListener?.(this.currentResult)\n  }\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  noop,\n  Console,\n  getStatusProps,\n  Updater,\n  replaceEqualDeep,\n} from './utils'\nimport {\n  ArrayQueryKey,\n  InfiniteQueryConfig,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryConfig,\n  QueryFunction,\n  QueryStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport { QueryObserver, UpdateListener } from './queryObserver'\n\n// TYPES\n\ninterface QueryInitConfig<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  notifyGlobalListeners: (query: Query<TResult, TError>) => void\n}\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  isError: boolean\n  isFetched: boolean\n  isFetching: boolean\n  isFetchingMore: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isStale: boolean\n  isSuccess: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nexport enum ActionType {\n  Failed = 'Failed',\n  MarkStale = 'MarkStale',\n  Fetch = 'Fetch',\n  Success = 'Success',\n  Error = 'Error',\n  SetState = 'SetState',\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface MarkStaleAction {\n  type: ActionType.MarkStale\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  data: TResult | undefined\n  isStale: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  cancelled: boolean\n  error: TError\n}\n\ninterface SetStateAction<TResult, TError> {\n  type: ActionType.SetState\n  updater: Updater<QueryState<TResult, TError>, QueryState<TResult, TError>>\n}\n\nexport type Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | MarkStaleAction\n  | SetStateAction<TResult, TError>\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  observers: QueryObserver<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  shouldContinueRetryOnFocus?: boolean\n  promise?: Promise<TResult | undefined>\n\n  private fetchMoreVariable?: unknown\n  private pageVariables?: ArrayQueryKey[]\n  private cacheTimeout?: number\n  private retryTimeout?: number\n  private staleTimeout?: number\n  private cancelPromises?: () => void\n  private cancelled?: typeof cancelledError | null\n  private notifyGlobalListeners: (query: Query<TResult, TError>) => void\n\n  constructor(init: QueryInitConfig<TResult, TError>) {\n    this.config = init.config\n    this.queryCache = init.queryCache\n    this.queryKey = init.queryKey\n    this.queryHash = init.queryHash\n    this.notifyGlobalListeners = init.notifyGlobalListeners\n    this.observers = []\n    this.state = getDefaultState(init.config)\n\n    if (init.config.infinite) {\n      const infiniteConfig = init.config as InfiniteQueryConfig<TResult, TError>\n      const infiniteData = (this.state.data as unknown) as TResult[] | undefined\n\n      if (typeof infiniteData !== 'undefined') {\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(\n          infiniteData[infiniteData.length - 1],\n          infiniteData\n        )\n        this.state.canFetchMore = Boolean(this.fetchMoreVariable)\n      }\n\n      // Here we seed the pageVariables for the query\n      if (!this.pageVariables) {\n        this.pageVariables = [[...this.queryKey]]\n      }\n    }\n\n    // If the query started with data, schedule\n    // a stale timeout\n    if (!isServer && this.state.data) {\n      this.scheduleStaleTimeout()\n\n      // Simulate a query healing process\n      this.heal()\n\n      // Schedule for garbage collection in case\n      // nothing subscribes to this query\n      this.scheduleGarbageCollection()\n    }\n  }\n\n  updateConfig(config: QueryConfig<TResult, TError>): void {\n    this.config = config\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    this.state = queryReducer(this.state, action)\n    this.observers.forEach(d => d.onQueryUpdate(this.state, action))\n    this.notifyGlobalListeners(this)\n  }\n\n  scheduleStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    if (this.state.isStale || this.config.staleTime === Infinity) {\n      return\n    }\n\n    this.staleTimeout = setTimeout(() => {\n      this.invalidate()\n    }, this.config.staleTime)\n  }\n\n  invalidate(): void {\n    this.clearStaleTimeout()\n\n    if (this.state.isStale) {\n      return\n    }\n\n    this.dispatch({ type: ActionType.MarkStale })\n  }\n\n  scheduleGarbageCollection(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearCacheTimeout()\n\n    if (this.config.cacheTime === Infinity) {\n      return\n    }\n\n    this.cacheTimeout = setTimeout(\n      () => {\n        this.clear()\n      },\n      typeof this.state.data === 'undefined' &&\n        this.state.status !== QueryStatus.Error\n        ? 0\n        : this.config.cacheTime\n    )\n  }\n\n  async refetch(): Promise<void> {\n    try {\n      await this.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  heal(): void {\n    // Stop the query from being garbage collected\n    this.clearCacheTimeout()\n\n    // Mark the query as not cancelled\n    this.cancelled = null\n  }\n\n  cancel(): void {\n    this.cancelled = cancelledError\n\n    if (this.cancelPromises) {\n      this.cancelPromises()\n    }\n\n    delete this.promise\n  }\n\n  private clearTimersObservers(): void {\n    this.observers.forEach(observer => {\n      observer.clearRefetchInterval()\n    })\n  }\n\n  private clearStaleTimeout() {\n    if (this.staleTimeout) {\n      clearTimeout(this.staleTimeout)\n      this.staleTimeout = undefined\n    }\n  }\n\n  private clearCacheTimeout() {\n    if (this.cacheTimeout) {\n      clearTimeout(this.cacheTimeout)\n      this.cacheTimeout = undefined\n    }\n  }\n\n  private clearRetryTimeout() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout)\n      this.retryTimeout = undefined\n    }\n  }\n\n  private setState(\n    updater: Updater<QueryState<TResult, TError>, QueryState<TResult, TError>>\n  ): void {\n    this.dispatch({ type: ActionType.SetState, updater })\n  }\n\n  setData(updater: Updater<TResult | undefined, TResult>): void {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data: TResult | undefined = functionalUpdate(updater, prevData)\n\n    // Structurally share data between prev and new data\n    data = replaceEqualDeep(prevData, data)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.config.isDataEqual?.(prevData, data)) {\n      data = prevData\n    }\n\n    const isStale = this.config.staleTime === 0\n\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      data,\n      isStale,\n    })\n\n    if (!isStale) {\n      // Schedule a fresh invalidation!\n      this.scheduleStaleTimeout()\n    }\n  }\n\n  clear(): void {\n    this.clearStaleTimeout()\n    this.clearCacheTimeout()\n    this.clearRetryTimeout()\n    this.clearTimersObservers()\n    this.cancel()\n    delete this.queryCache.queries[this.queryHash]\n    this.notifyGlobalListeners(this)\n  }\n\n  isEnabled(): boolean {\n    return this.observers.some(observer => observer.config.enabled)\n  }\n\n  shouldRefetchOnWindowFocus(): boolean {\n    return (\n      this.isEnabled() &&\n      this.state.isStale &&\n      this.observers.some(observer => observer.config.refetchOnWindowFocus)\n    )\n  }\n\n  subscribe(\n    listener?: UpdateListener<TResult, TError>\n  ): QueryObserver<TResult, TError> {\n    const observer = new QueryObserver<TResult, TError>({\n      queryCache: this.queryCache,\n      queryKey: this.queryKey,\n      ...this.config,\n    })\n\n    observer.subscribe(listener)\n\n    return observer\n  }\n\n  subscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers.push(observer)\n    this.heal()\n  }\n\n  unsubscribeObserver(\n    observer: QueryObserver<TResult, TError>,\n    preventGC?: boolean\n  ): void {\n    this.observers = this.observers.filter(x => x !== observer)\n\n    if (!this.observers.length) {\n      this.cancel()\n\n      if (!preventGC) {\n        // Schedule garbage collection\n        this.scheduleGarbageCollection()\n      }\n    }\n  }\n\n  // Set up the core fetcher function\n  private async tryFetchData(\n    fn: QueryFunction<TResult>,\n    args: ArrayQueryKey\n  ): Promise<TResult> {\n    try {\n      // Perform the query\n      const filter = this.config.queryFnParamsFilter\n      const params = filter ? filter(args) : args\n\n      // Perform the query\n      const promiseOrValue = fn(...params)\n\n      this.cancelPromises = () => (promiseOrValue as any)?.cancel?.()\n\n      const data = await promiseOrValue\n      delete this.shouldContinueRetryOnFocus\n\n      delete this.cancelPromises\n      if (this.cancelled) throw this.cancelled\n\n      return data\n    } catch (error) {\n      delete this.cancelPromises\n      if (this.cancelled) throw this.cancelled\n\n      // Do we need to retry the request?\n      if (\n        this.config.retry === true ||\n        this.state.failureCount < this.config.retry! ||\n        (typeof this.config.retry === 'function' &&\n          this.config.retry(this.state.failureCount, error))\n      ) {\n        // If we retry, increase the failureCount\n        this.dispatch({ type: ActionType.Failed })\n\n        // Only retry if the document is visible\n        if (!isDocumentVisible()) {\n          // set this flag to continue retries on focus\n          this.shouldContinueRetryOnFocus = true\n          // Resolve a\n          return new Promise(noop)\n        }\n\n        delete this.shouldContinueRetryOnFocus\n\n        // Determine the retryDelay\n        const delay = functionalUpdate(\n          this.config.retryDelay,\n          this.state.failureCount\n        )\n\n        // Return a new promise with the retry\n        return await new Promise((resolve, reject) => {\n          // Keep track of the retry timeout\n          this.retryTimeout = setTimeout(async () => {\n            if (this.cancelled) return reject(this.cancelled)\n\n            try {\n              const data = await this.tryFetchData(fn, args)\n              if (this.cancelled) return reject(this.cancelled)\n              resolve(data)\n            } catch (error) {\n              if (this.cancelled) return reject(this.cancelled)\n              reject(error)\n            }\n          }, delay)\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async fetch(options?: FetchOptions): Promise<TResult | undefined> {\n    let queryFn = this.config.queryFn\n\n    if (!queryFn) {\n      return\n    }\n\n    // If we are already fetching, return current promise\n    if (this.promise) {\n      return this.promise\n    }\n\n    if (this.config.infinite) {\n      const infiniteConfig = this.config as InfiniteQueryConfig<TResult, TError>\n      const infiniteData = (this.state.data as unknown) as TResult[] | undefined\n      const fetchMore = options?.fetchMore\n\n      const originalQueryFn = queryFn\n\n      queryFn = async () => {\n        const data: TResult[] = []\n        const pageVariables = this.pageVariables ? [...this.pageVariables] : []\n        const rebuiltPageVariables: ArrayQueryKey[] = []\n\n        do {\n          const args = pageVariables.shift()!\n\n          if (!data.length) {\n            // the first page query doesn't need to be rebuilt\n            data.push(await originalQueryFn(...args))\n            rebuiltPageVariables.push(args)\n          } else {\n            // get an up-to-date cursor based on the previous data set\n\n            const nextCursor = infiniteConfig.getFetchMore(\n              data[data.length - 1],\n              data\n            )\n\n            // break early if there's no next cursor\n            // otherwise we'll start from the beginning\n            // which will cause unwanted duplication\n            if (!nextCursor) {\n              break\n            }\n\n            const pageArgs = [\n              // remove the last argument (the previously saved cursor)\n              ...args.slice(0, -1),\n              nextCursor,\n            ] as ArrayQueryKey\n\n            data.push(await originalQueryFn(...pageArgs))\n            rebuiltPageVariables.push(pageArgs)\n          }\n        } while (pageVariables.length)\n\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(\n          data[data.length - 1],\n          data\n        )\n        this.state.canFetchMore = Boolean(this.fetchMoreVariable)\n        this.pageVariables = rebuiltPageVariables\n\n        return (data as unknown) as TResult\n      }\n\n      if (fetchMore) {\n        queryFn = async (...args: ArrayQueryKey) => {\n          try {\n            const { fetchMoreVariable, previous } = fetchMore\n\n            this.setState(old => ({\n              ...old,\n              isFetchingMore: previous ? 'previous' : 'next',\n            }))\n\n            const newArgs = [...args, fetchMoreVariable] as ArrayQueryKey\n\n            if (this.pageVariables) {\n              this.pageVariables[previous ? 'unshift' : 'push'](newArgs)\n            } else {\n              this.pageVariables = [newArgs]\n            }\n\n            const newData = await originalQueryFn(...newArgs)\n\n            let data\n\n            if (!infiniteData) {\n              data = [newData]\n            } else if (previous) {\n              data = [newData, ...infiniteData]\n            } else {\n              data = [...infiniteData, newData]\n            }\n\n            this.fetchMoreVariable = infiniteConfig.getFetchMore(newData, data)\n            this.state.canFetchMore = Boolean(this.fetchMoreVariable)\n\n            return (data as unknown) as TResult\n          } finally {\n            this.setState(old => ({\n              ...old,\n              isFetchingMore: false,\n            }))\n          }\n        }\n      }\n    }\n\n    this.promise = (async () => {\n      // If there are any retries pending for this query, kill them\n      this.cancelled = null\n\n      try {\n        // Set to fetching state if not already in it\n        if (!this.state.isFetching) {\n          this.dispatch({ type: ActionType.Fetch })\n        }\n\n        // Try to get the data\n        const data = await this.tryFetchData(queryFn!, this.queryKey)\n\n        this.setData(data)\n\n        delete this.promise\n\n        return data\n      } catch (error) {\n        this.dispatch({\n          type: ActionType.Error,\n          cancelled: error === this.cancelled,\n          error,\n        })\n\n        delete this.promise\n\n        if (error !== this.cancelled) {\n          throw error\n        }\n\n        return\n      }\n    })()\n\n    return this.promise\n  }\n\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable ?? this.fetchMoreVariable,\n        previous: options?.previous || false,\n      },\n    })\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: QueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const isStale =\n    !config.enabled ||\n    (typeof config.initialStale === 'function'\n      ? config.initialStale()\n      : config.initialStale ?? !hasInitialData)\n\n  const initialStatus = hasInitialData\n    ? QueryStatus.Success\n    : config.enabled\n    ? QueryStatus.Loading\n    : QueryStatus.Idle\n\n  return {\n    ...getStatusProps(initialStatus),\n    error: null,\n    isFetched: false,\n    isFetching: initialStatus === QueryStatus.Loading,\n    isFetchingMore: false,\n    failureCount: 0,\n    isStale,\n    data: initialData,\n    updatedAt: hasInitialData ? Date.now() : 0,\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.MarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case ActionType.Fetch:\n      const status =\n        typeof state.data !== 'undefined'\n          ? QueryStatus.Success\n          : QueryStatus.Loading\n      return {\n        ...state,\n        ...getStatusProps(status),\n        isFetching: true,\n        failureCount: 0,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n        isStale: action.isStale,\n        isFetched: true,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          ...getStatusProps(QueryStatus.Error),\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case ActionType.SetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      return state\n  }\n}\n","import {\n  isServer,\n  getQueryArgs,\n  deepIncludes,\n  Console,\n  isObject,\n  Updater,\n} from './utils'\nimport { getDefaultedQueryConfig } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryKey,\n  QueryKeyWithoutObject,\n  ReactQueryConfig,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from './types'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends QueryPredicateOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n  throwOnError?: boolean\n}\n\ninterface QueryPredicateOptions {\n  exact?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface PrefetchQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  queries: QueryHashMap\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private globalListeners: QueryCacheListener[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n\n    // A frozen cache does not add new queries to the cache\n    this.globalListeners = []\n\n    this.queries = {}\n    this.isFetching = 0\n  }\n\n  private notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = Object.values(this.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    this.globalListeners.forEach(d => d(this, query))\n  }\n\n  getDefaultConfig() {\n    return this.config.defaultConfig\n  }\n\n  getDefaultedQueryConfig<TResult, TError>(\n    config?: QueryConfig<TResult, TError>\n  ): QueryConfig<TResult, TError> {\n    return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {\n      queryCache: this,\n    })\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners.splice(this.globalListeners.indexOf(listener), 1)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    Object.values(this.queries).forEach(query => query.clear())\n    this.queries = {}\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    if (predicate === true) {\n      return Object.values(this.queries)\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const config = this.getDefaultedQueryConfig()\n      const [queryHash, queryKey] = config.queryKeySerializerFn!(predicate)\n\n      predicateFn = d =>\n        options?.exact\n          ? d.queryHash === queryHash\n          : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(this.queries).filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQueries(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => query.clear())\n  }\n\n  cancelQueries(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => query.cancel())\n  }\n\n  async invalidateQueries(\n    predicate: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<void> {\n    const { refetchActive = true, refetchInactive = false, throwOnError } =\n      options || {}\n\n    try {\n      await Promise.all(\n        this.getQueries(predicate, options).map(query => {\n          if (query.observers.length) {\n            if (refetchActive && query.isEnabled()) {\n              return query.fetch()\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch()\n            }\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    userQueryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const config = this.getDefaultedQueryConfig(queryConfig)\n\n    const [queryHash, queryKey] = config.queryKeySerializerFn!(userQueryKey)\n\n    let query\n\n    if (this.queries[queryHash]) {\n      query = this.queries[queryHash] as Query<TResult, TError>\n      query.updateConfig(config)\n    }\n\n    if (!query) {\n      query = new Query<TResult, TError>({\n        queryCache: this,\n        queryKey,\n        queryHash,\n        config,\n        notifyGlobalListeners: query => {\n          this.notifyGlobalListeners(query)\n        },\n      })\n\n      if (!this.config.frozen) {\n        this.queries[queryHash] = query\n\n        if (isServer) {\n          this.notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            this.notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    return query\n  }\n\n  // Parameter syntax with optional prefetch options\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n    queryKey: TKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with config and optional prefetch options\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n    queryKey: TKey,\n    config: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  async prefetchQuery<\n    TResult,\n    TError,\n    TKey extends QueryKeyWithoutObjectAndArray\n  >(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, [TKey]>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, TKey>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  async prefetchQuery<\n    TResult,\n    TError,\n    TKey extends QueryKeyWithoutObjectAndArray\n  >(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, [TKey]>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, TKey>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutArray>(\n    config: PrefetchQueryObjectConfig<TResult, TError, [TKey]>\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    config: PrefetchQueryObjectConfig<TResult, TError, TKey>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  async prefetchQuery<TResult, TError>(\n    ...args: any[]\n  ): Promise<TResult | undefined> {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(args)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    const configWithoutRetry = { retry: false, ...config }\n\n    try {\n      const query = this.buildQuery<TResult, TError>(\n        queryKey,\n        configWithoutRetry\n      )\n      if (options?.force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (options?.throwOnError) {\n        throw err\n      }\n      Console.error(err)\n      return\n    }\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config?: QueryConfig<TResult, TError>\n  ) {\n    let query = this.getQuery<TResult, TError>(queryKey)\n\n    if (!query) {\n      query = this.buildQuery<TResult, TError>(queryKey, config)\n    }\n\n    query.setData(updater)\n  }\n}\n\nconst defaultQueryCache = makeQueryCache({ frozen: isServer })\nexport { defaultQueryCache as queryCache }\nexport const queryCaches = [defaultQueryCache]\n\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\ntype FocusHandler = () => void\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus: FocusHandler = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.shouldRefetchOnWindowFocus()) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return true\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler: (() => void) | void\n\nexport function setFocusHandler(callback: (callback: FocusHandler) => void) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler((handleFocus: FocusHandler) => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n  return\n})\n","import React from 'react'\n\nimport {\n  queryCache as defaultQueryCache,\n  queryCaches,\n  makeQueryCache,\n} from '../core'\nimport { QueryCache } from '../core/queryCache'\n\nexport const queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { mergeReactQueryConfigs } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useContextConfig() {\n  return React.useContext(configContext)\n}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const parentConfig = useContextConfig()\n\n  const mergedConfig = React.useMemo(\n    () =>\n      parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config,\n    [config, parentConfig]\n  )\n\n  return (\n    <configContext.Provider value={mergedConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useDefaultedMutationConfig } from './useDefaultedMutationConfig'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n} from '../core/types'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nenum ActionType {\n  Reset = 'Reset',\n  Loading = 'Loading',\n  Resolve = 'Resolve',\n  Reject = 'Reject',\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nconst getDefaultState = (): State<any, any> => ({\n  ...getStatusProps(QueryStatus.Idle),\n  data: undefined,\n  error: null,\n})\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  config = useDefaultedMutationConfig(config)\n  const getConfig = useGetLatest(config)\n\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const latestMutationRef = React.useRef<number>()\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await config.onMutate?.(variables!)) as TSnapshot\n\n        const data = await getMutationFn()(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await config.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await config.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await config.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError ?? config.throwOnError) {\n          throw error\n        }\n\n        return\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\nimport { uid, isServer } from '../core/utils'\n\nexport function useUid(): number {\n  const ref = React.useRef(0)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function useGetLatest<T>(obj: T): () => T {\n  const ref = React.useRef<T>(obj)\n  ref.current = obj\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  return (React.useCallback(\n    (...args: any[]) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  ) as any) as T\n}\n\nexport function useRerenderer() {\n  const rerender = useMountedCallback(React.useState<unknown>()[1])\n  return React.useCallback(() => rerender({}), [rerender])\n}\n","import React from 'react'\n\nimport { useRerenderer, useGetLatest } from './utils'\nimport { useQueryCache } from './ReactQueryCacheProvider'\n\nexport function useIsFetching(): number {\n  const queryCache = useQueryCache()\n  const rerender = useRerenderer()\n  const isFetching = queryCache.isFetching\n\n  const getIsFetching = useGetLatest(isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(newCache => {\n        if (getIsFetching() !== newCache.isFetching) {\n          rerender()\n        }\n      }),\n    [getIsFetching, queryCache, rerender]\n  )\n\n  return isFetching\n}\n","import { MutationConfig } from '../core/types'\nimport { getDefaultedMutationConfig } from '../core/config'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  const contextConfig = useContextConfig()\n  const contextQueryCache = useQueryCache()\n  const queryCache = config?.queryCache || contextQueryCache\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {\n    queryCache,\n  })\n}\n","import React from 'react'\n\nimport { useRerenderer } from './utils'\nimport { QueryObserver } from '../core/queryObserver'\nimport { QueryResultBase, QueryObserverConfig } from '../core/types'\nimport { useDefaultedQueryConfig } from './useDefaultedQueryConfig'\n\nexport function useBaseQuery<TResult, TError>(\n  config: QueryObserverConfig<TResult, TError> = {}\n): QueryResultBase<TResult, TError> {\n  config = useDefaultedQueryConfig(config)\n\n  // Make a rerender function\n  const rerender = useRerenderer()\n\n  // Create query observer\n  const observerRef = React.useRef<QueryObserver<TResult, TError>>()\n  const firstRender = !observerRef.current\n  const observer = observerRef.current || new QueryObserver(config)\n  observerRef.current = observer\n\n  // Subscribe to the observer\n  React.useEffect(\n    () =>\n      observer.subscribe(() => {\n        Promise.resolve().then(rerender)\n      }),\n    [observer, rerender]\n  )\n\n  // Update config\n  if (!firstRender) {\n    observer.updateConfig(config)\n  }\n\n  const result = observer.getCurrentResult()\n\n  // Handle suspense\n  if (config.suspense || config.useErrorBoundary) {\n    if (result.isError && result.query.state.throwInErrorBoundary) {\n      throw result.error\n    }\n\n    if (config.enabled && config.suspense && !result.isSuccess) {\n      observer.subscribe()\n      throw observer.fetch().finally(() => {\n        observer.unsubscribe(true)\n      })\n    }\n  }\n\n  return result\n}\n","import { QueryConfig } from '../core/types'\nimport { getDefaultedQueryConfig } from '../core/config'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useDefaultedQueryConfig<TResult, TError>(\n  config?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  const contextConfig = useContextConfig()\n  const contextQueryCache = useQueryCache()\n  const queryCache = config?.queryCache || contextQueryCache\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {\n    queryCache,\n  })\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport {\n  QueryConfig,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  QueryResult,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, [TKey]>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n  queryKey: TKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Object syntax\nexport function useQuery<TResult, TError, TKey extends QueryKeyWithoutArray>(\n  config: UseQueryObjectConfig<TResult, TError, [TKey]>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UseQueryObjectConfig<TResult, TError, TKey>\n): QueryResult<TResult, TError>\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  ...args: any[]\n): QueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult, TError>(args)[1]\n  return useBaseQuery<TResult, TError>(config)\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObject\n>(\n  queryKey: TKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Object syntax\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutArray\n>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError, [TKey]>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError, TKey>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  ...args: any[]\n): PaginatedQueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult, TError>(args)[1]\n  const result = useBaseQuery<TResult, TError>({\n    ...config,\n    keepPreviousData: true,\n  })\n  return {\n    ...result,\n    resolvedData: result.data,\n    latestData:\n      result.query.state.data === result.data ? result.data : undefined,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObject\n>(\n  queryKey: TKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Object syntax\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutArray\n>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError, [TKey]>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError, TKey>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  ...args: any[]\n): InfiniteQueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult[], TError>(args)[1]\n  return useBaseQuery<TResult[], TError>({ ...config, infinite: true })\n}\n"],"names":["QueryStatus","_uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","setConsole","c","functionalUpdate","updater","input","stableStringifyReplacer","_key","value","Error","isObject","Object","keys","sort","reduce","result","key","stableStringify","JSON","stringify","deepIncludes","a","b","some","isDocumentVisible","document","undefined","includes","visibilityState","getQueryArgs","args","queryKey","queryFn","config","options","Array","isArray","isPlainObject","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","getStatusProps","status","isLoading","Loading","isSuccess","Success","isError","isIdle","Idle","DEFAULT_CONFIG","queries","queryKeySerializerFn","arrayQueryKey","queryHash","parse","enabled","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchOnWindowFocus","refetchOnMount","getDefaultedQueryConfig","queryCacheConfig","contextConfig","configOverrides","shared","QueryObserver","clear","this","bind","refetch","fetchMore","updateQuery","subscribe","listener","started","updateListener","currentQuery","subscribeObserver","optionalFetch","updateRefetchInterval","unsubscribe","preventGC","clearRefetchInterval","unsubscribeObserver","updateConfig","prevConfig","updated","refetchInterval","refetchIntervalInBackground","getCurrentResult","currentResult","fetchMoreVariable","fetch","catch","suspense","isFetched","isStale","observers","length","Infinity","refetchIntervalId","setInterval","_this7","clearInterval","createResult","previousResult","state","canFetchMore","failureCount","isFetching","isFetchingMore","data","updatedAt","keepPreviousData","query","prevQuery","initialData","newQuery","queryCache","buildQuery","onQueryUpdate","_state","action","type","onSuccess","onSettled","onError","body","recover","e","then","direct","Promise","resolve","f","i","arguments","apply","reject","pact","s","_settle","v","observer","ActionType","_Pact","onFulfilled","onRejected","callback","_this","thenable","thrown","finalizer","Query","init","hasInitialData","initialStatus","notifyGlobalListeners","initialStale","Date","now","infinite","infiniteConfig","infiniteData","getFetchMore","Boolean","pageVariables","scheduleStaleTimeout","heal","scheduleGarbageCollection","dispatch","Failed","MarkStale","Fetch","cancelled","throwInErrorBoundary","SetState","queryReducer","forEach","d","clearStaleTimeout","staleTimeout","setTimeout","_this2","invalidate","clearCacheTimeout","cacheTimeout","_this3","_this5","cancel","cancelPromises","promise","clearTimersObservers","clearTimeout","clearRetryTimeout","retryTimeout","setState","setData","prevData","replaceEqualDeep","array","aSize","bItems","bSize","copy","equalItems","isDataEqual","_this$config$isDataEq","isEnabled","shouldRefetchOnWindowFocus","push","filter","x","tryFetchData","fn","queryFnParamsFilter","params","promiseOrValue","_ref","shouldContinueRetryOnFocus","delay","_this9","originalQueryFn","rebuiltPageVariables","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","shift","nextCursor","pageArgs","slice","previous","old","newArgs","newData","_async","QueryCache","globalListeners","values","acc","getDefaultConfig","defaultConfig","splice","indexOf","notify","getQueries","predicate","predicateFn","exact","getQuery","getQueryData","_this$getQuery","removeQueries","cancelQueries","invalidateQueries","refetchActive","refetchInactive","throwOnError","all","_this4","map","err","resetErrorBoundaries","userQueryKey","queryConfig","frozen","prefetchQuery","configWithoutRetry","force","setQueryData","defaultQueryCache","makeQueryCache","queryCaches","removePreviousHandler","onWindowFocus","navigator","onLine","setFocusHandler","handleFocus","_window","addEventListener","removeEventListener","queryCacheContext","React","createContext","useQueryCache","useContext","ReactQueryCacheProvider","children","resolvedQueryCache","useMemo","useEffect","Provider","configContext","useContextConfig","ReactQueryConfigProvider","parentConfig","mergedConfig","mutations","useGetLatest","obj","ref","useRef","current","useCallback","useMountedCallback","mounted","useRerenderer","rerender","useState","useIsFetching","getIsFetching","newCache","useDefaultedMutationConfig","contextQueryCache","getDefaultedMutationConfig","_await","getDefaultState","mutationReducer","Reset","Resolve","Reject","useMutation","mutationFn","getConfig","useReducer","getMutationFn","latestMutationRef","mutate","variables","mutateConfig","mutationId","snapshotValue","isLatest","onMutate","reset","useErrorBoundary","useBaseQuery","useDefaultedQueryConfig","observerRef","firstRender","finally","useQuery","usePaginatedQuery","resolvedData","latestData","useInfiniteQuery"],"mappings":"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"}